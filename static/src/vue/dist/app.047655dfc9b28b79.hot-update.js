"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(typeof self !== 'undefined' ? self : this)["webpackHotUpdatevueapp"]("app",{

/***/ "./src/welchs.js":
/*!***********************!*\
  !*** ./src/welchs.js ***!
  \***********************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var mathjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! mathjs */ \"./node_modules/mathjs/lib/esm/entry/pureFunctionsAny.generated.js\");\n// function drawAlphaCurve(group1, crit_t_value){\n//     // Fill the area under the curve representing alpha.\n//     let alpha_curve = [];\n//     // this datapoint connects with the critical t vertical line\n//     alpha_curve.push({x: crit_t_value, y: t_Distrib(crit_t_value, group1.df)});\n//     for(var i = 0; i < group1.dist.length; i++) {\n//       if (group1.dist[i]['x'] > crit_t_value){\n//         alpha_curve.push({x: group1.dist[i]['x'], y: group1.dist[i]['y']});\n//       }\n//     }\n//     lineChart.data.datasets[3]['data'] = alpha_curve;\n//     lineChart.update();\n//   }\n\n//   function drawBetaCurve(group2, crit_t_value){\n//     // Fill the area under the curve representing beta.\n//     let beta_curve = [];\n//     for(var i = 0; i < group2.dist.length; i++) {\n//       if (group2.dist[i]['x'] < crit_t_value){\n//         beta_curve.push({x: group2.dist[i]['x'], y: group2.dist[i]['y']});\n//       }\n//     }\n//     // this datapoint connects with the critical t vertical line\n//     beta_curve.push({x: crit_t_value, y: t_Distrib(crit_t_value-ncp, group2.df)}); // ncp acts as offset\n//     lineChart.data.datasets[4]['data'] = beta_curve;\n//     lineChart.update();\n//   }\n\n// function t_Distrib(t, dof){\n//   // For a given x, return the t distribution y value.\n//   y = (math.gamma((dof+1)/2)/(math.sqrt(dof*math.pi)*math.gamma(dof/2))) * (1+((t**2)/dof))**(-(dof+1)/2);\n//   return math.round(y, 6);\n// }\n\n// function getAlpha(crit_t_value, df){\n//   return 1 - computeArea(crit_t_value, df);\n// }\n\n// function getBeta(crit_t_value_beta, df){\n//   return computeArea(crit_t_value_beta, df);\n// }\n\n// function getRocCurve(axes){\n//   console.log(\"axes.x_max\", axes.x_max);\n//   console.log(\"axes.x_min:\", axes.x_min);\n//   let partitions = 25;\n//   step_size = (axes.x_max - axes.x_min)/partitions;\n//   console.log(\"step_size:\", step_size);\n//   console.log();\n//   roc_curve=[];\n//   // crit_t_value_beta = crit_t_value - ncp;\n//   for(var i = 0; i <= partitions; i++) {\n//     roc_curve.push({x: getAlpha((axes.x_min+(i*step_size)), df), y: 1-getBeta(((axes.x_min+(i*step_size)))-ncp, df)});    \n//   }\n//   console.log(\"roc_curve:\", roc_curve);\n//   return roc_curve;\n// }\n\n// function getAUC(axes){\n//   // calculate AUC using the left Riemann Sum\n//   console.log(\"axes.x_max\", axes.x_max);\n//   console.log(\"axes.x_min:\", axes.x_min);\n//   let partitions = 500;\n//   let step_size = (axes.x_max - axes.x_min)/partitions;\n//   console.log(\"step_size:\", step_size);\n//   console.log();\n//   let roc_curve=[];\n//   let auc = 0;\n//   for (var i = 0; i <= partitions; i++) {\n//     roc_curve.push({x: getAlpha((axes.x_min+(i*step_size)), df), y: 1-getBeta(((axes.x_min+(i*step_size)))-ncp, df)});    \n//   }\n//   // calculate left Riemann Sum\n//   for (var i = 0; i < roc_curve.length-1; i++) {\n//     auc = auc + (roc_curve[i].x-roc_curve[i+1].x)*roc_curve[i].y;\n//   }\n\n//   console.log(\"auc:\", auc);\n//   return math.round(auc, 2);\n// }\n\n\n// import Chart from \"chart.js\";\n\nvar welchs = {\n  // // provides shorthand for getting element id\n  // elem(elem_id){\n  //   return document.getElementById(elem_id);\n  // },\n\n  getFalseDiscoveryRate(FP, TP) {\n    console.log(\"FDR input FP:\", FP);\n    console.log(\"FDR input TP:\", TP);\n    return mathjs__WEBPACK_IMPORTED_MODULE_0__.round(100 * Number(FP) / (Number(FP) + Number(TP)), 2);\n  }\n\n  // getAlpha(crit_t_value, df){\n  //   return 1 - computeArea(crit_t_value, df);\n  // },\n\n  // getBeta(crit_t_value_beta, df){\n  //   return computeArea(crit_t_value_beta, df);\n  // },\n\n  // getRocCurve(axes, df, ncp){\n  //   console.log(\"axes.x_max\", axes.x_max);\n  //   console.log(\"axes.x_min:\", axes.x_min);\n  //   let partitions = 25;\n  //   step_size = (axes.x_max - axes.x_min)/partitions;\n  //   console.log(\"step_size:\", step_size);\n  //   console.log();\n  //   roc_curve=[];\n  //   // crit_t_value_beta = crit_t_value - ncp;\n  //   for(var i = 0; i <= partitions; i++) {\n  //     roc_curve.push({x: getAlpha((axes.x_min+(i*step_size)), df), y: 1-getBeta(((axes.x_min+(i*step_size)))-ncp, df)});    \n  //   }\n  //   console.log(\"roc_curve:\", roc_curve);\n  //   return roc_curve;\n  // },\n\n  // roc_curve: \n  //   [{x:0.9995, y: 1}, \n  //   {x:0.999, y: 1}, \n  //   {x:0.9979, y: 0.9999}, \n  //   {x:0.9955, y: 0.9999}, \n  //   {x:0.9902, y: 0.9998}, \n  //   {x:0.9786, y: 0.9995}, \n  //   {x:0.9534, y: 0.9991}, \n  //   {x:0.9021, y: 0.9981}, \n  //   {x:0.8087, y: 0.996}, \n  //   {x:0.6644, y: 0.9914}, \n  //   {x:0.48419999999999996, y: 0.9813}, \n  //   {x:0.3077, y: 0.9591}, \n  //   {x:0.17179999999999995, y: 0.9134}, \n  //   {x:0.08660000000000001, y: 0.8282}, \n  //   {x:0.04090000000000005, y: 0.6923}, \n  //   {x:0.01870000000000005, y: 0.5158}, \n  //   {x:0.008600000000000052, y: 0.3356}, \n  //   {x:0.0040000000000000036, y: 0.19130000000000003}, \n  //   {x:0.0019000000000000128, y: 0.09789999999999999}, \n  //   {x:0.0009000000000000119, y: 0.046599999999999975}, \n  //   {x:0.0004999999999999449, y: 0.021399999999999975}, \n  //   {x:0.00019999999999997797, y: 0.009800000000000031}, \n  //   {x:0.00009999999999998899, y: 0.0044999999999999485}, \n  //   {x:0.00009999999999998899, y: 0.0020999999999999908}, \n  //   {x:0, y: 0.0010000000000000009}, \n  //   {x:0, y: 0.0004999999999999449}],\n\n  //   t_value: -2.2502,\n  //   p_value: 0.0255,\n\n  // getROCChart(roc_curve, t_value, p_value){\n  // return new Chart(elem(\"roc_curve\"), {\n  //     type: 'scatter',\n  //     data: {\n  //       datasets: [{\n  //           data: [\n  //             {x: 0, y: 0},\n  //             {x: 1, y: 1},\n  //           ],\n  //           label: \"refs\",\n  //           borderColor: \"transparent\",\n  //           fill: false\n  //         },{\n  //           data: [], \n  //           label: \"TPR\",\n  //           borderColor: \"#000000\",\n  //           backgroundColor: \"#000000\",\n  //           fill: true,\n  //           pointRadius: 4\n  //         }, {\n  //           data: [{x:0,y:0}, {x:1,y:1}], // random curve for reference\n  //           label: \"Random\",\n  //           borderColor: \"#dedede\",\n  //           fill: false\n  //         },{\n  //           data: roc_curve,\n  //           label: \"ROC curve\",\n  //           borderColor: \"#7600bc\",\n  //           backgroundColor: \"#ca5cdd\",\n  //           fill: true\n  //           // ,pointRadius: 4\n  //         }\n  //       ]\n  //     },\n  //     options: {\n  //       animation: false,\n  //       title: {\n  //         display: false,\n  //         text: 't-test'\n  //       },\n  //       legend:{\n  //         position: 'bottom',\n  //         labels: {\n  //           filter: function(item, chart) {\n  //               return !item.text.includes('refs'); // Remove the refs legend item\n  //             },\n  //            usePointStyle: true,\n  //          },\n  //       },\n  //       elements: {\n  //         point:{\n  //             radius: 0\n  //         }\n  //       },\n  //       scales: {\n  //         xAxes: [{\n  //             ticks : {\n  //               min: 0,\n  //               stepSize: 0.2,\n  //               // stepValue: 0.2,\n  //               steps: 10,\n  //               max: 1,\n  //             },\n  //           display: true,\n  //           gridLines: {\n  //             display:false,\n  //           },\n  //           scaleLabel: {\n  //             display: true,\n  //             labelString: 'False positive rate (\\u03B1)'\n  //           }\n  //         }],\n  //         yAxes: [{\n  //           ticks : {\n  //             min: 0,\n  //             stepSize: 0.2,\n  //             max: 1,\n  //           },\n  //           display: true,\n  //           scaleLabel: {\n  //             display: true,\n  //             labelString: 'True positive rate (1 - \\u03B2)'\n  //           },\n  //           gridLines: {\n  //               display:false\n  //           }\n  //         }]\n  //       },\n  //       annotation: {\n  //         annotations: [{\n  //           type: 'line',\n  //           mode: 'vertical',\n  //           scaleID: 'x-axis-1',\n  //           value: t_value,\n  //           borderColor: '#c8c8c8',\n  //           borderWidth: 2,\n  //           borderDash: [10,5],\n  //           label: {\n  //             enabled: true,\n  //             content: 'p = ',\n  //             backgroundColor: 'transparent',\n  //             fontColor: '#c8c8c8',\n  //             position: \"top\",\n  //           }\n  //         },{\n  //           type: 'line',\n  //           mode: 'vertical',\n  //           scaleID: 'x-axis-1',\n  //           value: p_value,\n  //           borderColor: '#ff7034',\n  //           borderWidth: 2,\n  //           label: {\n  //             enabled: true,\n  //             content: '',\n  //             backgroundColor: 'transparent',\n  //             fontColor: '#4d4e4f',\n  //             yAdjust: 20,\n  //             position: \"top\",\n  //           }\n  //         }\n  //         ],\n  //         drawTime: \"afterDatasetsDraw\" \n  //       }\n  //     }\n  //   });\n  // },\n\n  // computeArea(x, df) {\n  //     X=eval(x)\n  //     df=eval(df)\n  //     with (Math) {\n  //     if (df<=0) {\n  //       alert(\"Degrees of freedom must be positive\")\n  //     } else {\n  //       A=df/2;\n  //       S=A+.5;\n  //       Z=df/(df+X*X);\n  //       BT=exp(LogGamma(S)-LogGamma(.5)-LogGamma(A)+A*log(Z)+.5*log(1-Z));\n  //       if (Z<(A+1)/(S+2)) {\n  //         betacdf=BT*Betinc(Z,A,.5)\n  //       } else {\n  //         betacdf=1-BT*Betinc(1-Z,.5,A)\n  //       }\n  //       if (X<0) {\n  //         tcdf=betacdf/2\n  //       } else {\n  //         tcdf=1-betacdf/2\n  //       }\n  //     }\n  //     // tcdf=round(tcdf*100000)/100000;\n  //     // tcdf=tcdf*100000/100000;\n  //   }\n  //     return round(tcdf);\n  // },\n\n  // LogGamma(Z) {\n  //   with (Math) {\n  //     var S=1+76.18009173/Z-86.50532033/(Z+1)+24.01409822/(Z+2)-1.231739516/(Z+3)+.00120858003/(Z+4)-.00000536382/(Z+5);\n  //     var LG= (Z-.5)*log(Z+4.5)-(Z+4.5)+log(S*2.50662827465);\n  //   }\n  //   return LG\n  // },\n\n  // Betinc(X,A,B) {\n  //   var A0=0;\n  //   var B0=1;\n  //   var A1=1;\n  //   var B1=1;\n  //   var M9=0;\n  //   var A2=0;\n  //   var C9;\n  //   while (Math.abs((A1-A2)/A1)>.00001) {\n  //     A2=A1;\n  //     C9=-(A+M9)*(A+B+M9)*X/(A+2*M9)/(A+2*M9+1);\n  //     A0=A1+C9*A0;\n  //     B0=B1+C9*B0;\n  //     M9=M9+1;\n  //     C9=M9*(B-M9)*X/(A+2*M9-1)/(A+2*M9);\n  //     A1=A0+C9*A1;\n  //     B1=B0+C9*B1;\n  //     A0=A0/B1;\n  //     B0=B0/B1;\n  //     A1=A1/B1;\n  //     B1=1;\n  //   }\n  //   return A1/A\n  // },\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (welchs);\n\n// function getFalseDiscoveryRate(FP, TP){\n//   /*Calculate the False Discovery Rate (FDR)\n//   FP: False Positive\n//   TP: True Positive\n//   */\n//   return math.round(100*FP/(FP + TP),2);\n// }\n\n// function computeArea(x, df) {\n//     X=eval(x)\n//     df=eval(df)\n//     with (Math) {\n// \t\tif (df<=0) {\n// \t\t\talert(\"Degrees of freedom must be positive\")\n// \t\t} else {\n// \t\t\tA=df/2;\n// \t\t\tS=A+.5;\n// \t\t\tZ=df/(df+X*X);\n// \t\t\tBT=exp(LogGamma(S)-LogGamma(.5)-LogGamma(A)+A*log(Z)+.5*log(1-Z));\n// \t\t\tif (Z<(A+1)/(S+2)) {\n// \t\t\t\tbetacdf=BT*Betinc(Z,A,.5)\n// \t\t\t} else {\n// \t\t\t\tbetacdf=1-BT*Betinc(1-Z,.5,A)\n// \t\t\t}\n// \t\t\tif (X<0) {\n// \t\t\t\ttcdf=betacdf/2\n// \t\t\t} else {\n// \t\t\t\ttcdf=1-betacdf/2\n// \t\t\t}\n// \t\t}\n// \t\t// tcdf=round(tcdf*100000)/100000;\n// \t\t// tcdf=tcdf*100000/100000;\n// \t}\n//     return round(tcdf);\n// }\n\n// function LogGamma(Z) {\n// \twith (Math) {\n// \t\tvar S=1+76.18009173/Z-86.50532033/(Z+1)+24.01409822/(Z+2)-1.231739516/(Z+3)+.00120858003/(Z+4)-.00000536382/(Z+5);\n// \t\tvar LG= (Z-.5)*log(Z+4.5)-(Z+4.5)+log(S*2.50662827465);\n// \t}\n// \treturn LG\n// }\n\n// function Betinc(X,A,B) {\n// \tvar A0=0;\n// \tvar B0=1;\n// \tvar A1=1;\n// \tvar B1=1;\n// \tvar M9=0;\n// \tvar A2=0;\n// \tvar C9;\n// \twhile (Math.abs((A1-A2)/A1)>.00001) {\n// \t\tA2=A1;\n// \t\tC9=-(A+M9)*(A+B+M9)*X/(A+2*M9)/(A+2*M9+1);\n// \t\tA0=A1+C9*A0;\n// \t\tB0=B1+C9*B0;\n// \t\tM9=M9+1;\n// \t\tC9=M9*(B-M9)*X/(A+2*M9-1)/(A+2*M9);\n// \t\tA1=A0+C9*A1;\n// \t\tB1=B0+C9*B1;\n// \t\tA0=A0/B1;\n// \t\tB0=B0/B1;\n// \t\tA1=A1/B1;\n// \t\tB1=1;\n// \t}\n// \treturn A1/A\n// }\n\n// function getLineChart(axes, group1, group2, p_value, crit_t_value){\n//   return new Chart(elem(\"line_chart\"), {\n//       type: 'scatter',\n//       data: {\n//         datasets: [{\n//             data: [\n//               {x: axes.x_min, y: 0},\n//               {x: axes.x_max, y: 0},\n//             ],\n//             label: \"refs\",\n//             borderColor: \"transparent\",\n//             fill: false\n//           },{\n//             data: group1.dist,\n//             label: \"Group 1\",\n//             borderColor: \"#ff0000\",\n//             fill: false\n//           }, {\n//             data: group2.dist,\n//             label: \"Group 2\",\n//             borderColor: \"#0000ff\",\n//             fill: false,\n//           }, {\n//             data: [], // Alpha Curve\n//             label: \"\\u03B1\",\n//             borderColor: \"transparent\",\n//             backgroundColor: \"#ff000055\",\n//             fill: true\n//           }, {\n//             data: [], // Beta Curve\n//             label: \"\\u03B2\",\n//             borderColor: \"transparent\",\n//             backgroundColor: \"#0000ff55\",\n//             fill: true\n//           }\n//         ]\n//       },\n//       options: {\n//         animation: false,\n//         title: {\n//           display: false,\n//           text: 't-test'\n//         },\n//         legend:{\n//           position: 'bottom',\n//           labels: {\n//             filter: function(item, chart) {\n//                 return !item.text.includes('refs'); // Remove the refs legend item\n//               },\n//              usePointStyle: true,\n//            },\n//         },\n//         elements: {\n//           point:{\n//               radius: 0\n//           }\n//         },\n//         scales: {\n//           xAxes: [{\n//               ticks : {\n//               min: axes.x_min,\n//               stepSize: axes.step_size,\n//                   max: axes.x_max,\n//               },\n//             display: true,\n//             gridLines: {\n//               display:false,\n//             },\n//             scaleLabel: {\n//               display: true,\n//               labelString: 't'\n//             }\n//           }],\n//           yAxes: [{\n//             ticks : {\n//               min: 0,\n//               max: axes.y_max,\n//             },\n//             display: true,\n//             scaleLabel: {\n//               display: true,\n//               labelString: 'Normalized Frequency'\n//             },\n//             gridLines: {\n//                 display:false\n//             }\n//           }]\n//         },\n//         annotation: {\n//           annotations: [{\n//             type: 'line',\n//             mode: 'vertical',\n//             scaleID: 'x-axis-1',\n//             value: t_value,\n//             borderColor: '#c8c8c8',\n//             borderWidth: 2,\n//             borderDash: [10,5],\n//             label: {\n//               enabled: true,\n//               content: 'p = ' + p_value,\n//               backgroundColor: 'transparent',\n//               fontColor: '#c8c8c8',\n//               position: \"top\",\n//             }\n//           },{\n//             type: 'line',\n//             mode: 'vertical',\n//             scaleID: 'x-axis-1',\n//             value: crit_t_value,\n//             borderColor: '#ff7034',\n//             borderWidth: 2,\n//             label: {\n//               enabled: true,\n//               content: '\\u03B1',\n//               backgroundColor: 'transparent',\n//               fontColor: '#4d4e4f',\n//               yAdjust: 20,\n//               position: \"top\",\n//             }\n//           }\n//           ],\n//           drawTime: \"afterDatasetsDraw\" \n//         }\n//       }\n//     });\n// }\n\n// function getROCChart(roc_curve){\n//   return new Chart(elem(\"roc_curve\"), {\n//       type: 'scatter',\n//       data: {\n//         datasets: [{\n//             data: [\n//               {x: 0, y: 0},\n//               {x: 1, y: 1},\n//             ],\n//             label: \"refs\",\n//             borderColor: \"transparent\",\n//             fill: false\n//           },{\n//             data: [], \n//             label: \"TPR\",\n//             borderColor: \"#000000\",\n//             backgroundColor: \"#000000\",\n//             fill: true,\n//             pointRadius: 4\n//           }, {\n//             data: [{x:0,y:0}, {x:1,y:1}], // random curve for reference\n//             label: \"Random\",\n//             borderColor: \"#dedede\",\n//             fill: false\n//           },{\n//             data: roc_curve,\n//             label: \"ROC curve\",\n//             borderColor: \"#7600bc\",\n//             backgroundColor: \"#ca5cdd\",\n//             fill: true\n//             // ,pointRadius: 4\n//           }\n//         ]\n//       },\n//       options: {\n//         animation: false,\n//         title: {\n//           display: false,\n//           text: 't-test'\n//         },\n//         legend:{\n//           position: 'bottom',\n//           labels: {\n//             filter: function(item, chart) {\n//                 return !item.text.includes('refs'); // Remove the refs legend item\n//               },\n//              usePointStyle: true,\n//            },\n//         },\n//         elements: {\n//           point:{\n//               radius: 0\n//           }\n//         },\n//         scales: {\n//           xAxes: [{\n//               ticks : {\n//                 min: 0,\n//                 stepSize: 0.2,\n//                 // stepValue: 0.2,\n//                 steps: 10,\n//                 max: 1,\n//               },\n//             display: true,\n//             gridLines: {\n//               display:false,\n//             },\n//             scaleLabel: {\n//               display: true,\n//               labelString: 'False positive rate (\\u03B1)'\n//             }\n//           }],\n//           yAxes: [{\n//             ticks : {\n//               min: 0,\n//               stepSize: 0.2,\n//               max: 1,\n//             },\n//             display: true,\n//             scaleLabel: {\n//               display: true,\n//               labelString: 'True positive rate (1 - \\u03B2)'\n//             },\n//             gridLines: {\n//                 display:false\n//             }\n//           }]\n//         },\n//         annotation: {\n//           annotations: [{\n//             type: 'line',\n//             mode: 'vertical',\n//             scaleID: 'x-axis-1',\n//             value: t_value,\n//             borderColor: '#c8c8c8',\n//             borderWidth: 2,\n//             borderDash: [10,5],\n//             label: {\n//               enabled: true,\n//               content: 'p = ',\n//               backgroundColor: 'transparent',\n//               fontColor: '#c8c8c8',\n//               position: \"top\",\n//             }\n//           },{\n//             type: 'line',\n//             mode: 'vertical',\n//             scaleID: 'x-axis-1',\n//             value: p_value,\n//             borderColor: '#ff7034',\n//             borderWidth: 2,\n//             label: {\n//               enabled: true,\n//               content: '',\n//               backgroundColor: 'transparent',\n//               fontColor: '#4d4e4f',\n//               yAdjust: 20,\n//               position: \"top\",\n//             }\n//           }\n//           ],\n//           drawTime: \"afterDatasetsDraw\" \n//         }\n//       }\n//     });\n// }\n\n//     /*\n//     Functions below may be used at a future date.\n\n//     BELOW FOR NORMAL CURVE (Z-TEST)\n//     function error_f(x, mean, sd){\n//       return (1/(sd*math.sqrt(2*math.pi)))*math.exp((-((x-mean) ** 2))/(2*sd ** 2));\n//     }\n\n//     function area_under_curve(x1, x2, mean, sd){\n//       return -0.5*(math.erf((mean-x2)/(math.sqrt(2)*sd)) - math.erf((mean-x1)/(math.sqrt(2)*sd)));\n//     }\n\n//     const width  = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;\n//     if (width <= 1000){\n//       lineChart.options.annotation.annotations[0].label['enabled'] = true;\n//       lineChart.options.annotation.annotations[1].label['enabled'] = true;\n//       lineChart.update();\n//     }\n//     */\n\n//     /*\n//     Bayes Factor = Likelihood Ratio = Sensitivity / False Positive Rate\n//     *///# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvd2VsY2hzLmpzLmpzIiwibWFwcGluZ3MiOiI7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUdBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFPQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU1BOztBQUdBOztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFHQTtBQUNBOztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFHQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWVhcHAvLi9zcmMvd2VsY2hzLmpzP2RmOWUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gZnVuY3Rpb24gZHJhd0FscGhhQ3VydmUoZ3JvdXAxLCBjcml0X3RfdmFsdWUpe1xyXG4vLyAgICAgLy8gRmlsbCB0aGUgYXJlYSB1bmRlciB0aGUgY3VydmUgcmVwcmVzZW50aW5nIGFscGhhLlxyXG4vLyAgICAgbGV0IGFscGhhX2N1cnZlID0gW107XHJcbi8vICAgICAvLyB0aGlzIGRhdGFwb2ludCBjb25uZWN0cyB3aXRoIHRoZSBjcml0aWNhbCB0IHZlcnRpY2FsIGxpbmVcclxuLy8gICAgIGFscGhhX2N1cnZlLnB1c2goe3g6IGNyaXRfdF92YWx1ZSwgeTogdF9EaXN0cmliKGNyaXRfdF92YWx1ZSwgZ3JvdXAxLmRmKX0pO1xyXG4vLyAgICAgZm9yKHZhciBpID0gMDsgaSA8IGdyb3VwMS5kaXN0Lmxlbmd0aDsgaSsrKSB7XHJcbi8vICAgICAgIGlmIChncm91cDEuZGlzdFtpXVsneCddID4gY3JpdF90X3ZhbHVlKXtcclxuLy8gICAgICAgICBhbHBoYV9jdXJ2ZS5wdXNoKHt4OiBncm91cDEuZGlzdFtpXVsneCddLCB5OiBncm91cDEuZGlzdFtpXVsneSddfSk7XHJcbi8vICAgICAgIH1cclxuLy8gICAgIH1cclxuLy8gICAgIGxpbmVDaGFydC5kYXRhLmRhdGFzZXRzWzNdWydkYXRhJ10gPSBhbHBoYV9jdXJ2ZTtcclxuLy8gICAgIGxpbmVDaGFydC51cGRhdGUoKTtcclxuLy8gICB9XHJcbiAgXHJcbiAgXHJcbi8vICAgZnVuY3Rpb24gZHJhd0JldGFDdXJ2ZShncm91cDIsIGNyaXRfdF92YWx1ZSl7XHJcbi8vICAgICAvLyBGaWxsIHRoZSBhcmVhIHVuZGVyIHRoZSBjdXJ2ZSByZXByZXNlbnRpbmcgYmV0YS5cclxuLy8gICAgIGxldCBiZXRhX2N1cnZlID0gW107XHJcbi8vICAgICBmb3IodmFyIGkgPSAwOyBpIDwgZ3JvdXAyLmRpc3QubGVuZ3RoOyBpKyspIHtcclxuLy8gICAgICAgaWYgKGdyb3VwMi5kaXN0W2ldWyd4J10gPCBjcml0X3RfdmFsdWUpe1xyXG4vLyAgICAgICAgIGJldGFfY3VydmUucHVzaCh7eDogZ3JvdXAyLmRpc3RbaV1bJ3gnXSwgeTogZ3JvdXAyLmRpc3RbaV1bJ3knXX0pO1xyXG4vLyAgICAgICB9XHJcbi8vICAgICB9XHJcbi8vICAgICAvLyB0aGlzIGRhdGFwb2ludCBjb25uZWN0cyB3aXRoIHRoZSBjcml0aWNhbCB0IHZlcnRpY2FsIGxpbmVcclxuLy8gICAgIGJldGFfY3VydmUucHVzaCh7eDogY3JpdF90X3ZhbHVlLCB5OiB0X0Rpc3RyaWIoY3JpdF90X3ZhbHVlLW5jcCwgZ3JvdXAyLmRmKX0pOyAvLyBuY3AgYWN0cyBhcyBvZmZzZXRcclxuLy8gICAgIGxpbmVDaGFydC5kYXRhLmRhdGFzZXRzWzRdWydkYXRhJ10gPSBiZXRhX2N1cnZlO1xyXG4vLyAgICAgbGluZUNoYXJ0LnVwZGF0ZSgpO1xyXG4vLyAgIH1cclxuICBcclxuXHJcblxyXG5cclxuLy8gZnVuY3Rpb24gdF9EaXN0cmliKHQsIGRvZil7XHJcbi8vICAgLy8gRm9yIGEgZ2l2ZW4geCwgcmV0dXJuIHRoZSB0IGRpc3RyaWJ1dGlvbiB5IHZhbHVlLlxyXG4vLyAgIHkgPSAobWF0aC5nYW1tYSgoZG9mKzEpLzIpLyhtYXRoLnNxcnQoZG9mKm1hdGgucGkpKm1hdGguZ2FtbWEoZG9mLzIpKSkgKiAoMSsoKHQqKjIpL2RvZikpKiooLShkb2YrMSkvMik7XHJcbi8vICAgcmV0dXJuIG1hdGgucm91bmQoeSwgNik7XHJcbi8vIH1cclxuXHJcblxyXG4vLyBmdW5jdGlvbiBnZXRBbHBoYShjcml0X3RfdmFsdWUsIGRmKXtcclxuLy8gICByZXR1cm4gMSAtIGNvbXB1dGVBcmVhKGNyaXRfdF92YWx1ZSwgZGYpO1xyXG4vLyB9XHJcblxyXG4vLyBmdW5jdGlvbiBnZXRCZXRhKGNyaXRfdF92YWx1ZV9iZXRhLCBkZil7XHJcbi8vICAgcmV0dXJuIGNvbXB1dGVBcmVhKGNyaXRfdF92YWx1ZV9iZXRhLCBkZik7XHJcbi8vIH1cclxuXHJcblxyXG4vLyBmdW5jdGlvbiBnZXRSb2NDdXJ2ZShheGVzKXtcclxuLy8gICBjb25zb2xlLmxvZyhcImF4ZXMueF9tYXhcIiwgYXhlcy54X21heCk7XHJcbi8vICAgY29uc29sZS5sb2coXCJheGVzLnhfbWluOlwiLCBheGVzLnhfbWluKTtcclxuLy8gICBsZXQgcGFydGl0aW9ucyA9IDI1O1xyXG4vLyAgIHN0ZXBfc2l6ZSA9IChheGVzLnhfbWF4IC0gYXhlcy54X21pbikvcGFydGl0aW9ucztcclxuLy8gICBjb25zb2xlLmxvZyhcInN0ZXBfc2l6ZTpcIiwgc3RlcF9zaXplKTtcclxuLy8gICBjb25zb2xlLmxvZygpO1xyXG4vLyAgIHJvY19jdXJ2ZT1bXTtcclxuLy8gICAvLyBjcml0X3RfdmFsdWVfYmV0YSA9IGNyaXRfdF92YWx1ZSAtIG5jcDtcclxuLy8gICBmb3IodmFyIGkgPSAwOyBpIDw9IHBhcnRpdGlvbnM7IGkrKykge1xyXG4vLyAgICAgcm9jX2N1cnZlLnB1c2goe3g6IGdldEFscGhhKChheGVzLnhfbWluKyhpKnN0ZXBfc2l6ZSkpLCBkZiksIHk6IDEtZ2V0QmV0YSgoKGF4ZXMueF9taW4rKGkqc3RlcF9zaXplKSkpLW5jcCwgZGYpfSk7ICAgIFxyXG4vLyAgIH1cclxuLy8gICBjb25zb2xlLmxvZyhcInJvY19jdXJ2ZTpcIiwgcm9jX2N1cnZlKTtcclxuLy8gICByZXR1cm4gcm9jX2N1cnZlO1xyXG4vLyB9XHJcblxyXG5cclxuLy8gZnVuY3Rpb24gZ2V0QVVDKGF4ZXMpe1xyXG4vLyAgIC8vIGNhbGN1bGF0ZSBBVUMgdXNpbmcgdGhlIGxlZnQgUmllbWFubiBTdW1cclxuLy8gICBjb25zb2xlLmxvZyhcImF4ZXMueF9tYXhcIiwgYXhlcy54X21heCk7XHJcbi8vICAgY29uc29sZS5sb2coXCJheGVzLnhfbWluOlwiLCBheGVzLnhfbWluKTtcclxuLy8gICBsZXQgcGFydGl0aW9ucyA9IDUwMDtcclxuLy8gICBsZXQgc3RlcF9zaXplID0gKGF4ZXMueF9tYXggLSBheGVzLnhfbWluKS9wYXJ0aXRpb25zO1xyXG4vLyAgIGNvbnNvbGUubG9nKFwic3RlcF9zaXplOlwiLCBzdGVwX3NpemUpO1xyXG4vLyAgIGNvbnNvbGUubG9nKCk7XHJcbi8vICAgbGV0IHJvY19jdXJ2ZT1bXTtcclxuLy8gICBsZXQgYXVjID0gMDtcclxuLy8gICBmb3IgKHZhciBpID0gMDsgaSA8PSBwYXJ0aXRpb25zOyBpKyspIHtcclxuLy8gICAgIHJvY19jdXJ2ZS5wdXNoKHt4OiBnZXRBbHBoYSgoYXhlcy54X21pbisoaSpzdGVwX3NpemUpKSwgZGYpLCB5OiAxLWdldEJldGEoKChheGVzLnhfbWluKyhpKnN0ZXBfc2l6ZSkpKS1uY3AsIGRmKX0pOyAgICBcclxuLy8gICB9XHJcbi8vICAgLy8gY2FsY3VsYXRlIGxlZnQgUmllbWFubiBTdW1cclxuLy8gICBmb3IgKHZhciBpID0gMDsgaSA8IHJvY19jdXJ2ZS5sZW5ndGgtMTsgaSsrKSB7XHJcbi8vICAgICBhdWMgPSBhdWMgKyAocm9jX2N1cnZlW2ldLngtcm9jX2N1cnZlW2krMV0ueCkqcm9jX2N1cnZlW2ldLnk7XHJcbi8vICAgfVxyXG5cclxuLy8gICBjb25zb2xlLmxvZyhcImF1YzpcIiwgYXVjKTtcclxuLy8gICByZXR1cm4gbWF0aC5yb3VuZChhdWMsIDIpO1xyXG4vLyB9XHJcblxyXG5pbXBvcnQgKiBhcyBtYXRoIGZyb20gJ21hdGhqcyc7XHJcbi8vIGltcG9ydCBDaGFydCBmcm9tIFwiY2hhcnQuanNcIjtcclxuXHJcblxyXG52YXIgd2VsY2hzID0ge1xyXG5cclxuICAvLyAvLyBwcm92aWRlcyBzaG9ydGhhbmQgZm9yIGdldHRpbmcgZWxlbWVudCBpZFxyXG4gIC8vIGVsZW0oZWxlbV9pZCl7XHJcbiAgLy8gICByZXR1cm4gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZWxlbV9pZCk7XHJcbiAgLy8gfSxcclxuXHJcblxyXG4gIGdldEZhbHNlRGlzY292ZXJ5UmF0ZShGUCwgVFApIHtcclxuICAgIGNvbnNvbGUubG9nKFwiRkRSIGlucHV0IEZQOlwiLCBGUCk7XHJcbiAgICBjb25zb2xlLmxvZyhcIkZEUiBpbnB1dCBUUDpcIiwgVFApO1xyXG4gICAgcmV0dXJuIG1hdGgucm91bmQoMTAwKk51bWJlcihGUCkvKE51bWJlcihGUCkgKyBOdW1iZXIoVFApKSwyKTtcclxuICB9LFxyXG5cclxuXHJcblxyXG5cclxuICBcclxuXHJcbiAgLy8gZ2V0QWxwaGEoY3JpdF90X3ZhbHVlLCBkZil7XHJcbiAgLy8gICByZXR1cm4gMSAtIGNvbXB1dGVBcmVhKGNyaXRfdF92YWx1ZSwgZGYpO1xyXG4gIC8vIH0sXHJcblxyXG4gIC8vIGdldEJldGEoY3JpdF90X3ZhbHVlX2JldGEsIGRmKXtcclxuICAvLyAgIHJldHVybiBjb21wdXRlQXJlYShjcml0X3RfdmFsdWVfYmV0YSwgZGYpO1xyXG4gIC8vIH0sXHJcblxyXG5cclxuICAvLyBnZXRSb2NDdXJ2ZShheGVzLCBkZiwgbmNwKXtcclxuICAvLyAgIGNvbnNvbGUubG9nKFwiYXhlcy54X21heFwiLCBheGVzLnhfbWF4KTtcclxuICAvLyAgIGNvbnNvbGUubG9nKFwiYXhlcy54X21pbjpcIiwgYXhlcy54X21pbik7XHJcbiAgLy8gICBsZXQgcGFydGl0aW9ucyA9IDI1O1xyXG4gIC8vICAgc3RlcF9zaXplID0gKGF4ZXMueF9tYXggLSBheGVzLnhfbWluKS9wYXJ0aXRpb25zO1xyXG4gIC8vICAgY29uc29sZS5sb2coXCJzdGVwX3NpemU6XCIsIHN0ZXBfc2l6ZSk7XHJcbiAgLy8gICBjb25zb2xlLmxvZygpO1xyXG4gIC8vICAgcm9jX2N1cnZlPVtdO1xyXG4gIC8vICAgLy8gY3JpdF90X3ZhbHVlX2JldGEgPSBjcml0X3RfdmFsdWUgLSBuY3A7XHJcbiAgLy8gICBmb3IodmFyIGkgPSAwOyBpIDw9IHBhcnRpdGlvbnM7IGkrKykge1xyXG4gIC8vICAgICByb2NfY3VydmUucHVzaCh7eDogZ2V0QWxwaGEoKGF4ZXMueF9taW4rKGkqc3RlcF9zaXplKSksIGRmKSwgeTogMS1nZXRCZXRhKCgoYXhlcy54X21pbisoaSpzdGVwX3NpemUpKSktbmNwLCBkZil9KTsgICAgXHJcbiAgLy8gICB9XHJcbiAgLy8gICBjb25zb2xlLmxvZyhcInJvY19jdXJ2ZTpcIiwgcm9jX2N1cnZlKTtcclxuICAvLyAgIHJldHVybiByb2NfY3VydmU7XHJcbiAgLy8gfSxcclxuXHJcbiAgXHJcbiAgLy8gcm9jX2N1cnZlOiBcclxuICAvLyAgIFt7eDowLjk5OTUsIHk6IDF9LCBcclxuICAvLyAgIHt4OjAuOTk5LCB5OiAxfSwgXHJcbiAgLy8gICB7eDowLjk5NzksIHk6IDAuOTk5OX0sIFxyXG4gIC8vICAge3g6MC45OTU1LCB5OiAwLjk5OTl9LCBcclxuICAvLyAgIHt4OjAuOTkwMiwgeTogMC45OTk4fSwgXHJcbiAgLy8gICB7eDowLjk3ODYsIHk6IDAuOTk5NX0sIFxyXG4gIC8vICAge3g6MC45NTM0LCB5OiAwLjk5OTF9LCBcclxuICAvLyAgIHt4OjAuOTAyMSwgeTogMC45OTgxfSwgXHJcbiAgLy8gICB7eDowLjgwODcsIHk6IDAuOTk2fSwgXHJcbiAgLy8gICB7eDowLjY2NDQsIHk6IDAuOTkxNH0sIFxyXG4gIC8vICAge3g6MC40ODQxOTk5OTk5OTk5OTk5NiwgeTogMC45ODEzfSwgXHJcbiAgLy8gICB7eDowLjMwNzcsIHk6IDAuOTU5MX0sIFxyXG4gIC8vICAge3g6MC4xNzE3OTk5OTk5OTk5OTk5NSwgeTogMC45MTM0fSwgXHJcbiAgLy8gICB7eDowLjA4NjYwMDAwMDAwMDAwMDAxLCB5OiAwLjgyODJ9LCBcclxuICAvLyAgIHt4OjAuMDQwOTAwMDAwMDAwMDAwMDUsIHk6IDAuNjkyM30sIFxyXG4gIC8vICAge3g6MC4wMTg3MDAwMDAwMDAwMDAwNSwgeTogMC41MTU4fSwgXHJcbiAgLy8gICB7eDowLjAwODYwMDAwMDAwMDAwMDA1MiwgeTogMC4zMzU2fSwgXHJcbiAgLy8gICB7eDowLjAwNDAwMDAwMDAwMDAwMDAwMzYsIHk6IDAuMTkxMzAwMDAwMDAwMDAwMDN9LCBcclxuICAvLyAgIHt4OjAuMDAxOTAwMDAwMDAwMDAwMDEyOCwgeTogMC4wOTc4OTk5OTk5OTk5OTk5OX0sIFxyXG4gIC8vICAge3g6MC4wMDA5MDAwMDAwMDAwMDAwMTE5LCB5OiAwLjA0NjU5OTk5OTk5OTk5OTk3NX0sIFxyXG4gIC8vICAge3g6MC4wMDA0OTk5OTk5OTk5OTk5NDQ5LCB5OiAwLjAyMTM5OTk5OTk5OTk5OTk3NX0sIFxyXG4gIC8vICAge3g6MC4wMDAxOTk5OTk5OTk5OTk5Nzc5NywgeTogMC4wMDk4MDAwMDAwMDAwMDAwMzF9LCBcclxuICAvLyAgIHt4OjAuMDAwMDk5OTk5OTk5OTk5OTg4OTksIHk6IDAuMDA0NDk5OTk5OTk5OTk5OTQ4NX0sIFxyXG4gIC8vICAge3g6MC4wMDAwOTk5OTk5OTk5OTk5ODg5OSwgeTogMC4wMDIwOTk5OTk5OTk5OTk5OTA4fSwgXHJcbiAgLy8gICB7eDowLCB5OiAwLjAwMTAwMDAwMDAwMDAwMDAwMDl9LCBcclxuICAvLyAgIHt4OjAsIHk6IDAuMDAwNDk5OTk5OTk5OTk5OTQ0OX1dLFxyXG5cclxuXHJcbiAgLy8gICB0X3ZhbHVlOiAtMi4yNTAyLFxyXG4gIC8vICAgcF92YWx1ZTogMC4wMjU1LFxyXG5cclxuICAvLyBnZXRST0NDaGFydChyb2NfY3VydmUsIHRfdmFsdWUsIHBfdmFsdWUpe1xyXG4gIC8vIHJldHVybiBuZXcgQ2hhcnQoZWxlbShcInJvY19jdXJ2ZVwiKSwge1xyXG4gIC8vICAgICB0eXBlOiAnc2NhdHRlcicsXHJcbiAgLy8gICAgIGRhdGE6IHtcclxuICAvLyAgICAgICBkYXRhc2V0czogW3tcclxuICAvLyAgICAgICAgICAgZGF0YTogW1xyXG4gIC8vICAgICAgICAgICAgIHt4OiAwLCB5OiAwfSxcclxuICAvLyAgICAgICAgICAgICB7eDogMSwgeTogMX0sXHJcbiAgLy8gICAgICAgICAgIF0sXHJcbiAgLy8gICAgICAgICAgIGxhYmVsOiBcInJlZnNcIixcclxuICAvLyAgICAgICAgICAgYm9yZGVyQ29sb3I6IFwidHJhbnNwYXJlbnRcIixcclxuICAvLyAgICAgICAgICAgZmlsbDogZmFsc2VcclxuICAvLyAgICAgICAgIH0se1xyXG4gIC8vICAgICAgICAgICBkYXRhOiBbXSwgXHJcbiAgLy8gICAgICAgICAgIGxhYmVsOiBcIlRQUlwiLFxyXG4gIC8vICAgICAgICAgICBib3JkZXJDb2xvcjogXCIjMDAwMDAwXCIsXHJcbiAgLy8gICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogXCIjMDAwMDAwXCIsXHJcbiAgLy8gICAgICAgICAgIGZpbGw6IHRydWUsXHJcbiAgLy8gICAgICAgICAgIHBvaW50UmFkaXVzOiA0XHJcbiAgLy8gICAgICAgICB9LCB7XHJcbiAgLy8gICAgICAgICAgIGRhdGE6IFt7eDowLHk6MH0sIHt4OjEseToxfV0sIC8vIHJhbmRvbSBjdXJ2ZSBmb3IgcmVmZXJlbmNlXHJcbiAgLy8gICAgICAgICAgIGxhYmVsOiBcIlJhbmRvbVwiLFxyXG4gIC8vICAgICAgICAgICBib3JkZXJDb2xvcjogXCIjZGVkZWRlXCIsXHJcbiAgLy8gICAgICAgICAgIGZpbGw6IGZhbHNlXHJcbiAgLy8gICAgICAgICB9LHtcclxuICAvLyAgICAgICAgICAgZGF0YTogcm9jX2N1cnZlLFxyXG4gIC8vICAgICAgICAgICBsYWJlbDogXCJST0MgY3VydmVcIixcclxuICAvLyAgICAgICAgICAgYm9yZGVyQ29sb3I6IFwiIzc2MDBiY1wiLFxyXG4gIC8vICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiI2NhNWNkZFwiLFxyXG4gIC8vICAgICAgICAgICBmaWxsOiB0cnVlXHJcbiAgLy8gICAgICAgICAgIC8vICxwb2ludFJhZGl1czogNFxyXG4gIC8vICAgICAgICAgfVxyXG4gIC8vICAgICAgIF1cclxuICAvLyAgICAgfSxcclxuICAvLyAgICAgb3B0aW9uczoge1xyXG4gIC8vICAgICAgIGFuaW1hdGlvbjogZmFsc2UsXHJcbiAgLy8gICAgICAgdGl0bGU6IHtcclxuICAvLyAgICAgICAgIGRpc3BsYXk6IGZhbHNlLFxyXG4gIC8vICAgICAgICAgdGV4dDogJ3QtdGVzdCdcclxuICAvLyAgICAgICB9LFxyXG4gIC8vICAgICAgIGxlZ2VuZDp7XHJcbiAgLy8gICAgICAgICBwb3NpdGlvbjogJ2JvdHRvbScsXHJcbiAgLy8gICAgICAgICBsYWJlbHM6IHtcclxuICAvLyAgICAgICAgICAgZmlsdGVyOiBmdW5jdGlvbihpdGVtLCBjaGFydCkge1xyXG4gIC8vICAgICAgICAgICAgICAgcmV0dXJuICFpdGVtLnRleHQuaW5jbHVkZXMoJ3JlZnMnKTsgLy8gUmVtb3ZlIHRoZSByZWZzIGxlZ2VuZCBpdGVtXHJcbiAgLy8gICAgICAgICAgICAgfSxcclxuICAvLyAgICAgICAgICAgIHVzZVBvaW50U3R5bGU6IHRydWUsXHJcbiAgLy8gICAgICAgICAgfSxcclxuICAvLyAgICAgICB9LFxyXG4gIC8vICAgICAgIGVsZW1lbnRzOiB7XHJcbiAgLy8gICAgICAgICBwb2ludDp7XHJcbiAgLy8gICAgICAgICAgICAgcmFkaXVzOiAwXHJcbiAgLy8gICAgICAgICB9XHJcbiAgLy8gICAgICAgfSxcclxuICAvLyAgICAgICBzY2FsZXM6IHtcclxuICAvLyAgICAgICAgIHhBeGVzOiBbe1xyXG4gIC8vICAgICAgICAgICAgIHRpY2tzIDoge1xyXG4gIC8vICAgICAgICAgICAgICAgbWluOiAwLFxyXG4gIC8vICAgICAgICAgICAgICAgc3RlcFNpemU6IDAuMixcclxuICAvLyAgICAgICAgICAgICAgIC8vIHN0ZXBWYWx1ZTogMC4yLFxyXG4gIC8vICAgICAgICAgICAgICAgc3RlcHM6IDEwLFxyXG4gIC8vICAgICAgICAgICAgICAgbWF4OiAxLFxyXG4gIC8vICAgICAgICAgICAgIH0sXHJcbiAgLy8gICAgICAgICAgIGRpc3BsYXk6IHRydWUsXHJcbiAgLy8gICAgICAgICAgIGdyaWRMaW5lczoge1xyXG4gIC8vICAgICAgICAgICAgIGRpc3BsYXk6ZmFsc2UsXHJcbiAgLy8gICAgICAgICAgIH0sXHJcbiAgLy8gICAgICAgICAgIHNjYWxlTGFiZWw6IHtcclxuICAvLyAgICAgICAgICAgICBkaXNwbGF5OiB0cnVlLFxyXG4gIC8vICAgICAgICAgICAgIGxhYmVsU3RyaW5nOiAnRmFsc2UgcG9zaXRpdmUgcmF0ZSAoXFx1MDNCMSknXHJcbiAgLy8gICAgICAgICAgIH1cclxuICAvLyAgICAgICAgIH1dLFxyXG4gIC8vICAgICAgICAgeUF4ZXM6IFt7XHJcbiAgLy8gICAgICAgICAgIHRpY2tzIDoge1xyXG4gIC8vICAgICAgICAgICAgIG1pbjogMCxcclxuICAvLyAgICAgICAgICAgICBzdGVwU2l6ZTogMC4yLFxyXG4gIC8vICAgICAgICAgICAgIG1heDogMSxcclxuICAvLyAgICAgICAgICAgfSxcclxuICAvLyAgICAgICAgICAgZGlzcGxheTogdHJ1ZSxcclxuICAvLyAgICAgICAgICAgc2NhbGVMYWJlbDoge1xyXG4gIC8vICAgICAgICAgICAgIGRpc3BsYXk6IHRydWUsXHJcbiAgLy8gICAgICAgICAgICAgbGFiZWxTdHJpbmc6ICdUcnVlIHBvc2l0aXZlIHJhdGUgKDEgLSBcXHUwM0IyKSdcclxuICAvLyAgICAgICAgICAgfSxcclxuICAvLyAgICAgICAgICAgZ3JpZExpbmVzOiB7XHJcbiAgLy8gICAgICAgICAgICAgICBkaXNwbGF5OmZhbHNlXHJcbiAgLy8gICAgICAgICAgIH1cclxuICAvLyAgICAgICAgIH1dXHJcbiAgLy8gICAgICAgfSxcclxuICAvLyAgICAgICBhbm5vdGF0aW9uOiB7XHJcbiAgLy8gICAgICAgICBhbm5vdGF0aW9uczogW3tcclxuICAvLyAgICAgICAgICAgdHlwZTogJ2xpbmUnLFxyXG4gIC8vICAgICAgICAgICBtb2RlOiAndmVydGljYWwnLFxyXG4gIC8vICAgICAgICAgICBzY2FsZUlEOiAneC1heGlzLTEnLFxyXG4gIC8vICAgICAgICAgICB2YWx1ZTogdF92YWx1ZSxcclxuICAvLyAgICAgICAgICAgYm9yZGVyQ29sb3I6ICcjYzhjOGM4JyxcclxuICAvLyAgICAgICAgICAgYm9yZGVyV2lkdGg6IDIsXHJcbiAgLy8gICAgICAgICAgIGJvcmRlckRhc2g6IFsxMCw1XSxcclxuICAvLyAgICAgICAgICAgbGFiZWw6IHtcclxuICAvLyAgICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxyXG4gIC8vICAgICAgICAgICAgIGNvbnRlbnQ6ICdwID0gJyxcclxuICAvLyAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICd0cmFuc3BhcmVudCcsXHJcbiAgLy8gICAgICAgICAgICAgZm9udENvbG9yOiAnI2M4YzhjOCcsXHJcbiAgLy8gICAgICAgICAgICAgcG9zaXRpb246IFwidG9wXCIsXHJcbiAgLy8gICAgICAgICAgIH1cclxuICAvLyAgICAgICAgIH0se1xyXG4gIC8vICAgICAgICAgICB0eXBlOiAnbGluZScsXHJcbiAgLy8gICAgICAgICAgIG1vZGU6ICd2ZXJ0aWNhbCcsXHJcbiAgLy8gICAgICAgICAgIHNjYWxlSUQ6ICd4LWF4aXMtMScsXHJcbiAgLy8gICAgICAgICAgIHZhbHVlOiBwX3ZhbHVlLFxyXG4gIC8vICAgICAgICAgICBib3JkZXJDb2xvcjogJyNmZjcwMzQnLFxyXG4gIC8vICAgICAgICAgICBib3JkZXJXaWR0aDogMixcclxuICAvLyAgICAgICAgICAgbGFiZWw6IHtcclxuICAvLyAgICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxyXG4gIC8vICAgICAgICAgICAgIGNvbnRlbnQ6ICcnLFxyXG4gIC8vICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJ3RyYW5zcGFyZW50JyxcclxuICAvLyAgICAgICAgICAgICBmb250Q29sb3I6ICcjNGQ0ZTRmJyxcclxuICAvLyAgICAgICAgICAgICB5QWRqdXN0OiAyMCxcclxuICAvLyAgICAgICAgICAgICBwb3NpdGlvbjogXCJ0b3BcIixcclxuICAvLyAgICAgICAgICAgfVxyXG4gIC8vICAgICAgICAgfVxyXG4gIC8vICAgICAgICAgXSxcclxuICAvLyAgICAgICAgIGRyYXdUaW1lOiBcImFmdGVyRGF0YXNldHNEcmF3XCIgXHJcbiAgLy8gICAgICAgfVxyXG4gIC8vICAgICB9XHJcbiAgLy8gICB9KTtcclxuICAvLyB9LFxyXG5cclxuICAgIFxyXG4gIC8vIGNvbXB1dGVBcmVhKHgsIGRmKSB7XHJcbiAgLy8gICAgIFg9ZXZhbCh4KVxyXG4gIC8vICAgICBkZj1ldmFsKGRmKVxyXG4gIC8vICAgICB3aXRoIChNYXRoKSB7XHJcbiAgLy8gICAgIGlmIChkZjw9MCkge1xyXG4gIC8vICAgICAgIGFsZXJ0KFwiRGVncmVlcyBvZiBmcmVlZG9tIG11c3QgYmUgcG9zaXRpdmVcIilcclxuICAvLyAgICAgfSBlbHNlIHtcclxuICAvLyAgICAgICBBPWRmLzI7XHJcbiAgLy8gICAgICAgUz1BKy41O1xyXG4gIC8vICAgICAgIFo9ZGYvKGRmK1gqWCk7XHJcbiAgLy8gICAgICAgQlQ9ZXhwKExvZ0dhbW1hKFMpLUxvZ0dhbW1hKC41KS1Mb2dHYW1tYShBKStBKmxvZyhaKSsuNSpsb2coMS1aKSk7XHJcbiAgLy8gICAgICAgaWYgKFo8KEErMSkvKFMrMikpIHtcclxuICAvLyAgICAgICAgIGJldGFjZGY9QlQqQmV0aW5jKFosQSwuNSlcclxuICAvLyAgICAgICB9IGVsc2Uge1xyXG4gIC8vICAgICAgICAgYmV0YWNkZj0xLUJUKkJldGluYygxLVosLjUsQSlcclxuICAvLyAgICAgICB9XHJcbiAgLy8gICAgICAgaWYgKFg8MCkge1xyXG4gIC8vICAgICAgICAgdGNkZj1iZXRhY2RmLzJcclxuICAvLyAgICAgICB9IGVsc2Uge1xyXG4gIC8vICAgICAgICAgdGNkZj0xLWJldGFjZGYvMlxyXG4gIC8vICAgICAgIH1cclxuICAvLyAgICAgfVxyXG4gIC8vICAgICAvLyB0Y2RmPXJvdW5kKHRjZGYqMTAwMDAwKS8xMDAwMDA7XHJcbiAgLy8gICAgIC8vIHRjZGY9dGNkZioxMDAwMDAvMTAwMDAwO1xyXG4gIC8vICAgfVxyXG4gIC8vICAgICByZXR1cm4gcm91bmQodGNkZik7XHJcbiAgLy8gfSxcclxuXHJcbiAgLy8gTG9nR2FtbWEoWikge1xyXG4gIC8vICAgd2l0aCAoTWF0aCkge1xyXG4gIC8vICAgICB2YXIgUz0xKzc2LjE4MDA5MTczL1otODYuNTA1MzIwMzMvKForMSkrMjQuMDE0MDk4MjIvKForMiktMS4yMzE3Mzk1MTYvKForMykrLjAwMTIwODU4MDAzLyhaKzQpLS4wMDAwMDUzNjM4Mi8oWis1KTtcclxuICAvLyAgICAgdmFyIExHPSAoWi0uNSkqbG9nKForNC41KS0oWis0LjUpK2xvZyhTKjIuNTA2NjI4Mjc0NjUpO1xyXG4gIC8vICAgfVxyXG4gIC8vICAgcmV0dXJuIExHXHJcbiAgLy8gfSxcclxuXHJcbiAgLy8gQmV0aW5jKFgsQSxCKSB7XHJcbiAgLy8gICB2YXIgQTA9MDtcclxuICAvLyAgIHZhciBCMD0xO1xyXG4gIC8vICAgdmFyIEExPTE7XHJcbiAgLy8gICB2YXIgQjE9MTtcclxuICAvLyAgIHZhciBNOT0wO1xyXG4gIC8vICAgdmFyIEEyPTA7XHJcbiAgLy8gICB2YXIgQzk7XHJcbiAgLy8gICB3aGlsZSAoTWF0aC5hYnMoKEExLUEyKS9BMSk+LjAwMDAxKSB7XHJcbiAgLy8gICAgIEEyPUExO1xyXG4gIC8vICAgICBDOT0tKEErTTkpKihBK0IrTTkpKlgvKEErMipNOSkvKEErMipNOSsxKTtcclxuICAvLyAgICAgQTA9QTErQzkqQTA7XHJcbiAgLy8gICAgIEIwPUIxK0M5KkIwO1xyXG4gIC8vICAgICBNOT1NOSsxO1xyXG4gIC8vICAgICBDOT1NOSooQi1NOSkqWC8oQSsyKk05LTEpLyhBKzIqTTkpO1xyXG4gIC8vICAgICBBMT1BMCtDOSpBMTtcclxuICAvLyAgICAgQjE9QjArQzkqQjE7XHJcbiAgLy8gICAgIEEwPUEwL0IxO1xyXG4gIC8vICAgICBCMD1CMC9CMTtcclxuICAvLyAgICAgQTE9QTEvQjE7XHJcbiAgLy8gICAgIEIxPTE7XHJcbiAgLy8gICB9XHJcbiAgLy8gICByZXR1cm4gQTEvQVxyXG4gIC8vIH0sXHJcblxyXG5cclxuXHJcblxyXG5cclxufVxyXG5cclxuXHJcbmV4cG9ydCBkZWZhdWx0IHdlbGNocyBcclxuXHJcblxyXG4vLyBmdW5jdGlvbiBnZXRGYWxzZURpc2NvdmVyeVJhdGUoRlAsIFRQKXtcclxuLy8gICAvKkNhbGN1bGF0ZSB0aGUgRmFsc2UgRGlzY292ZXJ5IFJhdGUgKEZEUilcclxuLy8gICBGUDogRmFsc2UgUG9zaXRpdmVcclxuLy8gICBUUDogVHJ1ZSBQb3NpdGl2ZVxyXG4vLyAgICovXHJcbi8vICAgcmV0dXJuIG1hdGgucm91bmQoMTAwKkZQLyhGUCArIFRQKSwyKTtcclxuLy8gfVxyXG5cclxuXHJcblxyXG4vLyBmdW5jdGlvbiBjb21wdXRlQXJlYSh4LCBkZikge1xyXG4vLyAgICAgWD1ldmFsKHgpXHJcbi8vICAgICBkZj1ldmFsKGRmKVxyXG4vLyAgICAgd2l0aCAoTWF0aCkge1xyXG4vLyBcdFx0aWYgKGRmPD0wKSB7XHJcbi8vIFx0XHRcdGFsZXJ0KFwiRGVncmVlcyBvZiBmcmVlZG9tIG11c3QgYmUgcG9zaXRpdmVcIilcclxuLy8gXHRcdH0gZWxzZSB7XHJcbi8vIFx0XHRcdEE9ZGYvMjtcclxuLy8gXHRcdFx0Uz1BKy41O1xyXG4vLyBcdFx0XHRaPWRmLyhkZitYKlgpO1xyXG4vLyBcdFx0XHRCVD1leHAoTG9nR2FtbWEoUyktTG9nR2FtbWEoLjUpLUxvZ0dhbW1hKEEpK0EqbG9nKFopKy41KmxvZygxLVopKTtcclxuLy8gXHRcdFx0aWYgKFo8KEErMSkvKFMrMikpIHtcclxuLy8gXHRcdFx0XHRiZXRhY2RmPUJUKkJldGluYyhaLEEsLjUpXHJcbi8vIFx0XHRcdH0gZWxzZSB7XHJcbi8vIFx0XHRcdFx0YmV0YWNkZj0xLUJUKkJldGluYygxLVosLjUsQSlcclxuLy8gXHRcdFx0fVxyXG4vLyBcdFx0XHRpZiAoWDwwKSB7XHJcbi8vIFx0XHRcdFx0dGNkZj1iZXRhY2RmLzJcclxuLy8gXHRcdFx0fSBlbHNlIHtcclxuLy8gXHRcdFx0XHR0Y2RmPTEtYmV0YWNkZi8yXHJcbi8vIFx0XHRcdH1cclxuLy8gXHRcdH1cclxuLy8gXHRcdC8vIHRjZGY9cm91bmQodGNkZioxMDAwMDApLzEwMDAwMDtcclxuLy8gXHRcdC8vIHRjZGY9dGNkZioxMDAwMDAvMTAwMDAwO1xyXG4vLyBcdH1cclxuLy8gICAgIHJldHVybiByb3VuZCh0Y2RmKTtcclxuLy8gfVxyXG5cclxuXHJcblxyXG4vLyBmdW5jdGlvbiBMb2dHYW1tYShaKSB7XHJcbi8vIFx0d2l0aCAoTWF0aCkge1xyXG4vLyBcdFx0dmFyIFM9MSs3Ni4xODAwOTE3My9aLTg2LjUwNTMyMDMzLyhaKzEpKzI0LjAxNDA5ODIyLyhaKzIpLTEuMjMxNzM5NTE2LyhaKzMpKy4wMDEyMDg1ODAwMy8oWis0KS0uMDAwMDA1MzYzODIvKForNSk7XHJcbi8vIFx0XHR2YXIgTEc9IChaLS41KSpsb2coWis0LjUpLShaKzQuNSkrbG9nKFMqMi41MDY2MjgyNzQ2NSk7XHJcbi8vIFx0fVxyXG4vLyBcdHJldHVybiBMR1xyXG4vLyB9XHJcblxyXG4vLyBmdW5jdGlvbiBCZXRpbmMoWCxBLEIpIHtcclxuLy8gXHR2YXIgQTA9MDtcclxuLy8gXHR2YXIgQjA9MTtcclxuLy8gXHR2YXIgQTE9MTtcclxuLy8gXHR2YXIgQjE9MTtcclxuLy8gXHR2YXIgTTk9MDtcclxuLy8gXHR2YXIgQTI9MDtcclxuLy8gXHR2YXIgQzk7XHJcbi8vIFx0d2hpbGUgKE1hdGguYWJzKChBMS1BMikvQTEpPi4wMDAwMSkge1xyXG4vLyBcdFx0QTI9QTE7XHJcbi8vIFx0XHRDOT0tKEErTTkpKihBK0IrTTkpKlgvKEErMipNOSkvKEErMipNOSsxKTtcclxuLy8gXHRcdEEwPUExK0M5KkEwO1xyXG4vLyBcdFx0QjA9QjErQzkqQjA7XHJcbi8vIFx0XHRNOT1NOSsxO1xyXG4vLyBcdFx0Qzk9TTkqKEItTTkpKlgvKEErMipNOS0xKS8oQSsyKk05KTtcclxuLy8gXHRcdEExPUEwK0M5KkExO1xyXG4vLyBcdFx0QjE9QjArQzkqQjE7XHJcbi8vIFx0XHRBMD1BMC9CMTtcclxuLy8gXHRcdEIwPUIwL0IxO1xyXG4vLyBcdFx0QTE9QTEvQjE7XHJcbi8vIFx0XHRCMT0xO1xyXG4vLyBcdH1cclxuLy8gXHRyZXR1cm4gQTEvQVxyXG4vLyB9XHJcblxyXG5cclxuXHJcblxyXG5cclxuLy8gZnVuY3Rpb24gZ2V0TGluZUNoYXJ0KGF4ZXMsIGdyb3VwMSwgZ3JvdXAyLCBwX3ZhbHVlLCBjcml0X3RfdmFsdWUpe1xyXG4vLyAgIHJldHVybiBuZXcgQ2hhcnQoZWxlbShcImxpbmVfY2hhcnRcIiksIHtcclxuLy8gICAgICAgdHlwZTogJ3NjYXR0ZXInLFxyXG4vLyAgICAgICBkYXRhOiB7XHJcbi8vICAgICAgICAgZGF0YXNldHM6IFt7XHJcbi8vICAgICAgICAgICAgIGRhdGE6IFtcclxuLy8gICAgICAgICAgICAgICB7eDogYXhlcy54X21pbiwgeTogMH0sXHJcbi8vICAgICAgICAgICAgICAge3g6IGF4ZXMueF9tYXgsIHk6IDB9LFxyXG4vLyAgICAgICAgICAgICBdLFxyXG4vLyAgICAgICAgICAgICBsYWJlbDogXCJyZWZzXCIsXHJcbi8vICAgICAgICAgICAgIGJvcmRlckNvbG9yOiBcInRyYW5zcGFyZW50XCIsXHJcbi8vICAgICAgICAgICAgIGZpbGw6IGZhbHNlXHJcbi8vICAgICAgICAgICB9LHtcclxuLy8gICAgICAgICAgICAgZGF0YTogZ3JvdXAxLmRpc3QsXHJcbi8vICAgICAgICAgICAgIGxhYmVsOiBcIkdyb3VwIDFcIixcclxuLy8gICAgICAgICAgICAgYm9yZGVyQ29sb3I6IFwiI2ZmMDAwMFwiLFxyXG4vLyAgICAgICAgICAgICBmaWxsOiBmYWxzZVxyXG4vLyAgICAgICAgICAgfSwge1xyXG4vLyAgICAgICAgICAgICBkYXRhOiBncm91cDIuZGlzdCxcclxuLy8gICAgICAgICAgICAgbGFiZWw6IFwiR3JvdXAgMlwiLFxyXG4vLyAgICAgICAgICAgICBib3JkZXJDb2xvcjogXCIjMDAwMGZmXCIsXHJcbi8vICAgICAgICAgICAgIGZpbGw6IGZhbHNlLFxyXG4vLyAgICAgICAgICAgfSwge1xyXG4vLyAgICAgICAgICAgICBkYXRhOiBbXSwgLy8gQWxwaGEgQ3VydmVcclxuLy8gICAgICAgICAgICAgbGFiZWw6IFwiXFx1MDNCMVwiLFxyXG4vLyAgICAgICAgICAgICBib3JkZXJDb2xvcjogXCJ0cmFuc3BhcmVudFwiLFxyXG4vLyAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiI2ZmMDAwMDU1XCIsXHJcbi8vICAgICAgICAgICAgIGZpbGw6IHRydWVcclxuLy8gICAgICAgICAgIH0sIHtcclxuLy8gICAgICAgICAgICAgZGF0YTogW10sIC8vIEJldGEgQ3VydmVcclxuLy8gICAgICAgICAgICAgbGFiZWw6IFwiXFx1MDNCMlwiLFxyXG4vLyAgICAgICAgICAgICBib3JkZXJDb2xvcjogXCJ0cmFuc3BhcmVudFwiLFxyXG4vLyAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiIzAwMDBmZjU1XCIsXHJcbi8vICAgICAgICAgICAgIGZpbGw6IHRydWVcclxuLy8gICAgICAgICAgIH1cclxuLy8gICAgICAgICBdXHJcbi8vICAgICAgIH0sXHJcbi8vICAgICAgIG9wdGlvbnM6IHtcclxuLy8gICAgICAgICBhbmltYXRpb246IGZhbHNlLFxyXG4vLyAgICAgICAgIHRpdGxlOiB7XHJcbi8vICAgICAgICAgICBkaXNwbGF5OiBmYWxzZSxcclxuLy8gICAgICAgICAgIHRleHQ6ICd0LXRlc3QnXHJcbi8vICAgICAgICAgfSxcclxuLy8gICAgICAgICBsZWdlbmQ6e1xyXG4vLyAgICAgICAgICAgcG9zaXRpb246ICdib3R0b20nLFxyXG4vLyAgICAgICAgICAgbGFiZWxzOiB7XHJcbi8vICAgICAgICAgICAgIGZpbHRlcjogZnVuY3Rpb24oaXRlbSwgY2hhcnQpIHtcclxuLy8gICAgICAgICAgICAgICAgIHJldHVybiAhaXRlbS50ZXh0LmluY2x1ZGVzKCdyZWZzJyk7IC8vIFJlbW92ZSB0aGUgcmVmcyBsZWdlbmQgaXRlbVxyXG4vLyAgICAgICAgICAgICAgIH0sXHJcbi8vICAgICAgICAgICAgICB1c2VQb2ludFN0eWxlOiB0cnVlLFxyXG4vLyAgICAgICAgICAgIH0sXHJcbi8vICAgICAgICAgfSxcclxuLy8gICAgICAgICBlbGVtZW50czoge1xyXG4vLyAgICAgICAgICAgcG9pbnQ6e1xyXG4vLyAgICAgICAgICAgICAgIHJhZGl1czogMFxyXG4vLyAgICAgICAgICAgfVxyXG4vLyAgICAgICAgIH0sXHJcbi8vICAgICAgICAgc2NhbGVzOiB7XHJcbi8vICAgICAgICAgICB4QXhlczogW3tcclxuLy8gICAgICAgICAgICAgICB0aWNrcyA6IHtcclxuLy8gICAgICAgICAgICAgICBtaW46IGF4ZXMueF9taW4sXHJcbi8vICAgICAgICAgICAgICAgc3RlcFNpemU6IGF4ZXMuc3RlcF9zaXplLFxyXG4vLyAgICAgICAgICAgICAgICAgICBtYXg6IGF4ZXMueF9tYXgsXHJcbi8vICAgICAgICAgICAgICAgfSxcclxuLy8gICAgICAgICAgICAgZGlzcGxheTogdHJ1ZSxcclxuLy8gICAgICAgICAgICAgZ3JpZExpbmVzOiB7XHJcbi8vICAgICAgICAgICAgICAgZGlzcGxheTpmYWxzZSxcclxuLy8gICAgICAgICAgICAgfSxcclxuLy8gICAgICAgICAgICAgc2NhbGVMYWJlbDoge1xyXG4vLyAgICAgICAgICAgICAgIGRpc3BsYXk6IHRydWUsXHJcbi8vICAgICAgICAgICAgICAgbGFiZWxTdHJpbmc6ICd0J1xyXG4vLyAgICAgICAgICAgICB9XHJcbi8vICAgICAgICAgICB9XSxcclxuLy8gICAgICAgICAgIHlBeGVzOiBbe1xyXG4vLyAgICAgICAgICAgICB0aWNrcyA6IHtcclxuLy8gICAgICAgICAgICAgICBtaW46IDAsXHJcbi8vICAgICAgICAgICAgICAgbWF4OiBheGVzLnlfbWF4LFxyXG4vLyAgICAgICAgICAgICB9LFxyXG4vLyAgICAgICAgICAgICBkaXNwbGF5OiB0cnVlLFxyXG4vLyAgICAgICAgICAgICBzY2FsZUxhYmVsOiB7XHJcbi8vICAgICAgICAgICAgICAgZGlzcGxheTogdHJ1ZSxcclxuLy8gICAgICAgICAgICAgICBsYWJlbFN0cmluZzogJ05vcm1hbGl6ZWQgRnJlcXVlbmN5J1xyXG4vLyAgICAgICAgICAgICB9LFxyXG4vLyAgICAgICAgICAgICBncmlkTGluZXM6IHtcclxuLy8gICAgICAgICAgICAgICAgIGRpc3BsYXk6ZmFsc2VcclxuLy8gICAgICAgICAgICAgfVxyXG4vLyAgICAgICAgICAgfV1cclxuLy8gICAgICAgICB9LFxyXG4vLyAgICAgICAgIGFubm90YXRpb246IHtcclxuLy8gICAgICAgICAgIGFubm90YXRpb25zOiBbe1xyXG4vLyAgICAgICAgICAgICB0eXBlOiAnbGluZScsXHJcbi8vICAgICAgICAgICAgIG1vZGU6ICd2ZXJ0aWNhbCcsXHJcbi8vICAgICAgICAgICAgIHNjYWxlSUQ6ICd4LWF4aXMtMScsXHJcbi8vICAgICAgICAgICAgIHZhbHVlOiB0X3ZhbHVlLFxyXG4vLyAgICAgICAgICAgICBib3JkZXJDb2xvcjogJyNjOGM4YzgnLFxyXG4vLyAgICAgICAgICAgICBib3JkZXJXaWR0aDogMixcclxuLy8gICAgICAgICAgICAgYm9yZGVyRGFzaDogWzEwLDVdLFxyXG4vLyAgICAgICAgICAgICBsYWJlbDoge1xyXG4vLyAgICAgICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXHJcbi8vICAgICAgICAgICAgICAgY29udGVudDogJ3AgPSAnICsgcF92YWx1ZSxcclxuLy8gICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICd0cmFuc3BhcmVudCcsXHJcbi8vICAgICAgICAgICAgICAgZm9udENvbG9yOiAnI2M4YzhjOCcsXHJcbi8vICAgICAgICAgICAgICAgcG9zaXRpb246IFwidG9wXCIsXHJcbi8vICAgICAgICAgICAgIH1cclxuLy8gICAgICAgICAgIH0se1xyXG4vLyAgICAgICAgICAgICB0eXBlOiAnbGluZScsXHJcbi8vICAgICAgICAgICAgIG1vZGU6ICd2ZXJ0aWNhbCcsXHJcbi8vICAgICAgICAgICAgIHNjYWxlSUQ6ICd4LWF4aXMtMScsXHJcbi8vICAgICAgICAgICAgIHZhbHVlOiBjcml0X3RfdmFsdWUsXHJcbi8vICAgICAgICAgICAgIGJvcmRlckNvbG9yOiAnI2ZmNzAzNCcsXHJcbi8vICAgICAgICAgICAgIGJvcmRlcldpZHRoOiAyLFxyXG4vLyAgICAgICAgICAgICBsYWJlbDoge1xyXG4vLyAgICAgICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXHJcbi8vICAgICAgICAgICAgICAgY29udGVudDogJ1xcdTAzQjEnLFxyXG4vLyAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJ3RyYW5zcGFyZW50JyxcclxuLy8gICAgICAgICAgICAgICBmb250Q29sb3I6ICcjNGQ0ZTRmJyxcclxuLy8gICAgICAgICAgICAgICB5QWRqdXN0OiAyMCxcclxuLy8gICAgICAgICAgICAgICBwb3NpdGlvbjogXCJ0b3BcIixcclxuLy8gICAgICAgICAgICAgfVxyXG4vLyAgICAgICAgICAgfVxyXG4vLyAgICAgICAgICAgXSxcclxuLy8gICAgICAgICAgIGRyYXdUaW1lOiBcImFmdGVyRGF0YXNldHNEcmF3XCIgXHJcbi8vICAgICAgICAgfVxyXG4vLyAgICAgICB9XHJcbi8vICAgICB9KTtcclxuLy8gfVxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG4vLyBmdW5jdGlvbiBnZXRST0NDaGFydChyb2NfY3VydmUpe1xyXG4vLyAgIHJldHVybiBuZXcgQ2hhcnQoZWxlbShcInJvY19jdXJ2ZVwiKSwge1xyXG4vLyAgICAgICB0eXBlOiAnc2NhdHRlcicsXHJcbi8vICAgICAgIGRhdGE6IHtcclxuLy8gICAgICAgICBkYXRhc2V0czogW3tcclxuLy8gICAgICAgICAgICAgZGF0YTogW1xyXG4vLyAgICAgICAgICAgICAgIHt4OiAwLCB5OiAwfSxcclxuLy8gICAgICAgICAgICAgICB7eDogMSwgeTogMX0sXHJcbi8vICAgICAgICAgICAgIF0sXHJcbi8vICAgICAgICAgICAgIGxhYmVsOiBcInJlZnNcIixcclxuLy8gICAgICAgICAgICAgYm9yZGVyQ29sb3I6IFwidHJhbnNwYXJlbnRcIixcclxuLy8gICAgICAgICAgICAgZmlsbDogZmFsc2VcclxuLy8gICAgICAgICAgIH0se1xyXG4vLyAgICAgICAgICAgICBkYXRhOiBbXSwgXHJcbi8vICAgICAgICAgICAgIGxhYmVsOiBcIlRQUlwiLFxyXG4vLyAgICAgICAgICAgICBib3JkZXJDb2xvcjogXCIjMDAwMDAwXCIsXHJcbi8vICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogXCIjMDAwMDAwXCIsXHJcbi8vICAgICAgICAgICAgIGZpbGw6IHRydWUsXHJcbi8vICAgICAgICAgICAgIHBvaW50UmFkaXVzOiA0XHJcbi8vICAgICAgICAgICB9LCB7XHJcbi8vICAgICAgICAgICAgIGRhdGE6IFt7eDowLHk6MH0sIHt4OjEseToxfV0sIC8vIHJhbmRvbSBjdXJ2ZSBmb3IgcmVmZXJlbmNlXHJcbi8vICAgICAgICAgICAgIGxhYmVsOiBcIlJhbmRvbVwiLFxyXG4vLyAgICAgICAgICAgICBib3JkZXJDb2xvcjogXCIjZGVkZWRlXCIsXHJcbi8vICAgICAgICAgICAgIGZpbGw6IGZhbHNlXHJcbi8vICAgICAgICAgICB9LHtcclxuLy8gICAgICAgICAgICAgZGF0YTogcm9jX2N1cnZlLFxyXG4vLyAgICAgICAgICAgICBsYWJlbDogXCJST0MgY3VydmVcIixcclxuLy8gICAgICAgICAgICAgYm9yZGVyQ29sb3I6IFwiIzc2MDBiY1wiLFxyXG4vLyAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiI2NhNWNkZFwiLFxyXG4vLyAgICAgICAgICAgICBmaWxsOiB0cnVlXHJcbi8vICAgICAgICAgICAgIC8vICxwb2ludFJhZGl1czogNFxyXG4vLyAgICAgICAgICAgfVxyXG4vLyAgICAgICAgIF1cclxuLy8gICAgICAgfSxcclxuLy8gICAgICAgb3B0aW9uczoge1xyXG4vLyAgICAgICAgIGFuaW1hdGlvbjogZmFsc2UsXHJcbi8vICAgICAgICAgdGl0bGU6IHtcclxuLy8gICAgICAgICAgIGRpc3BsYXk6IGZhbHNlLFxyXG4vLyAgICAgICAgICAgdGV4dDogJ3QtdGVzdCdcclxuLy8gICAgICAgICB9LFxyXG4vLyAgICAgICAgIGxlZ2VuZDp7XHJcbi8vICAgICAgICAgICBwb3NpdGlvbjogJ2JvdHRvbScsXHJcbi8vICAgICAgICAgICBsYWJlbHM6IHtcclxuLy8gICAgICAgICAgICAgZmlsdGVyOiBmdW5jdGlvbihpdGVtLCBjaGFydCkge1xyXG4vLyAgICAgICAgICAgICAgICAgcmV0dXJuICFpdGVtLnRleHQuaW5jbHVkZXMoJ3JlZnMnKTsgLy8gUmVtb3ZlIHRoZSByZWZzIGxlZ2VuZCBpdGVtXHJcbi8vICAgICAgICAgICAgICAgfSxcclxuLy8gICAgICAgICAgICAgIHVzZVBvaW50U3R5bGU6IHRydWUsXHJcbi8vICAgICAgICAgICAgfSxcclxuLy8gICAgICAgICB9LFxyXG4vLyAgICAgICAgIGVsZW1lbnRzOiB7XHJcbi8vICAgICAgICAgICBwb2ludDp7XHJcbi8vICAgICAgICAgICAgICAgcmFkaXVzOiAwXHJcbi8vICAgICAgICAgICB9XHJcbi8vICAgICAgICAgfSxcclxuLy8gICAgICAgICBzY2FsZXM6IHtcclxuLy8gICAgICAgICAgIHhBeGVzOiBbe1xyXG4vLyAgICAgICAgICAgICAgIHRpY2tzIDoge1xyXG4vLyAgICAgICAgICAgICAgICAgbWluOiAwLFxyXG4vLyAgICAgICAgICAgICAgICAgc3RlcFNpemU6IDAuMixcclxuLy8gICAgICAgICAgICAgICAgIC8vIHN0ZXBWYWx1ZTogMC4yLFxyXG4vLyAgICAgICAgICAgICAgICAgc3RlcHM6IDEwLFxyXG4vLyAgICAgICAgICAgICAgICAgbWF4OiAxLFxyXG4vLyAgICAgICAgICAgICAgIH0sXHJcbi8vICAgICAgICAgICAgIGRpc3BsYXk6IHRydWUsXHJcbi8vICAgICAgICAgICAgIGdyaWRMaW5lczoge1xyXG4vLyAgICAgICAgICAgICAgIGRpc3BsYXk6ZmFsc2UsXHJcbi8vICAgICAgICAgICAgIH0sXHJcbi8vICAgICAgICAgICAgIHNjYWxlTGFiZWw6IHtcclxuLy8gICAgICAgICAgICAgICBkaXNwbGF5OiB0cnVlLFxyXG4vLyAgICAgICAgICAgICAgIGxhYmVsU3RyaW5nOiAnRmFsc2UgcG9zaXRpdmUgcmF0ZSAoXFx1MDNCMSknXHJcbi8vICAgICAgICAgICAgIH1cclxuLy8gICAgICAgICAgIH1dLFxyXG4vLyAgICAgICAgICAgeUF4ZXM6IFt7XHJcbi8vICAgICAgICAgICAgIHRpY2tzIDoge1xyXG4vLyAgICAgICAgICAgICAgIG1pbjogMCxcclxuLy8gICAgICAgICAgICAgICBzdGVwU2l6ZTogMC4yLFxyXG4vLyAgICAgICAgICAgICAgIG1heDogMSxcclxuLy8gICAgICAgICAgICAgfSxcclxuLy8gICAgICAgICAgICAgZGlzcGxheTogdHJ1ZSxcclxuLy8gICAgICAgICAgICAgc2NhbGVMYWJlbDoge1xyXG4vLyAgICAgICAgICAgICAgIGRpc3BsYXk6IHRydWUsXHJcbi8vICAgICAgICAgICAgICAgbGFiZWxTdHJpbmc6ICdUcnVlIHBvc2l0aXZlIHJhdGUgKDEgLSBcXHUwM0IyKSdcclxuLy8gICAgICAgICAgICAgfSxcclxuLy8gICAgICAgICAgICAgZ3JpZExpbmVzOiB7XHJcbi8vICAgICAgICAgICAgICAgICBkaXNwbGF5OmZhbHNlXHJcbi8vICAgICAgICAgICAgIH1cclxuLy8gICAgICAgICAgIH1dXHJcbi8vICAgICAgICAgfSxcclxuLy8gICAgICAgICBhbm5vdGF0aW9uOiB7XHJcbi8vICAgICAgICAgICBhbm5vdGF0aW9uczogW3tcclxuLy8gICAgICAgICAgICAgdHlwZTogJ2xpbmUnLFxyXG4vLyAgICAgICAgICAgICBtb2RlOiAndmVydGljYWwnLFxyXG4vLyAgICAgICAgICAgICBzY2FsZUlEOiAneC1heGlzLTEnLFxyXG4vLyAgICAgICAgICAgICB2YWx1ZTogdF92YWx1ZSxcclxuLy8gICAgICAgICAgICAgYm9yZGVyQ29sb3I6ICcjYzhjOGM4JyxcclxuLy8gICAgICAgICAgICAgYm9yZGVyV2lkdGg6IDIsXHJcbi8vICAgICAgICAgICAgIGJvcmRlckRhc2g6IFsxMCw1XSxcclxuLy8gICAgICAgICAgICAgbGFiZWw6IHtcclxuLy8gICAgICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxyXG4vLyAgICAgICAgICAgICAgIGNvbnRlbnQ6ICdwID0gJyxcclxuLy8gICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICd0cmFuc3BhcmVudCcsXHJcbi8vICAgICAgICAgICAgICAgZm9udENvbG9yOiAnI2M4YzhjOCcsXHJcbi8vICAgICAgICAgICAgICAgcG9zaXRpb246IFwidG9wXCIsXHJcbi8vICAgICAgICAgICAgIH1cclxuLy8gICAgICAgICAgIH0se1xyXG4vLyAgICAgICAgICAgICB0eXBlOiAnbGluZScsXHJcbi8vICAgICAgICAgICAgIG1vZGU6ICd2ZXJ0aWNhbCcsXHJcbi8vICAgICAgICAgICAgIHNjYWxlSUQ6ICd4LWF4aXMtMScsXHJcbi8vICAgICAgICAgICAgIHZhbHVlOiBwX3ZhbHVlLFxyXG4vLyAgICAgICAgICAgICBib3JkZXJDb2xvcjogJyNmZjcwMzQnLFxyXG4vLyAgICAgICAgICAgICBib3JkZXJXaWR0aDogMixcclxuLy8gICAgICAgICAgICAgbGFiZWw6IHtcclxuLy8gICAgICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxyXG4vLyAgICAgICAgICAgICAgIGNvbnRlbnQ6ICcnLFxyXG4vLyAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJ3RyYW5zcGFyZW50JyxcclxuLy8gICAgICAgICAgICAgICBmb250Q29sb3I6ICcjNGQ0ZTRmJyxcclxuLy8gICAgICAgICAgICAgICB5QWRqdXN0OiAyMCxcclxuLy8gICAgICAgICAgICAgICBwb3NpdGlvbjogXCJ0b3BcIixcclxuLy8gICAgICAgICAgICAgfVxyXG4vLyAgICAgICAgICAgfVxyXG4vLyAgICAgICAgICAgXSxcclxuLy8gICAgICAgICAgIGRyYXdUaW1lOiBcImFmdGVyRGF0YXNldHNEcmF3XCIgXHJcbi8vICAgICAgICAgfVxyXG4vLyAgICAgICB9XHJcbi8vICAgICB9KTtcclxuLy8gfVxyXG5cclxuXHJcbi8vICAgICAvKlxyXG4vLyAgICAgRnVuY3Rpb25zIGJlbG93IG1heSBiZSB1c2VkIGF0IGEgZnV0dXJlIGRhdGUuXHJcblxyXG5cclxuLy8gICAgIEJFTE9XIEZPUiBOT1JNQUwgQ1VSVkUgKFotVEVTVClcclxuLy8gICAgIGZ1bmN0aW9uIGVycm9yX2YoeCwgbWVhbiwgc2Qpe1xyXG4vLyAgICAgICByZXR1cm4gKDEvKHNkKm1hdGguc3FydCgyKm1hdGgucGkpKSkqbWF0aC5leHAoKC0oKHgtbWVhbikgKiogMikpLygyKnNkICoqIDIpKTtcclxuLy8gICAgIH1cclxuXHJcbi8vICAgICBmdW5jdGlvbiBhcmVhX3VuZGVyX2N1cnZlKHgxLCB4MiwgbWVhbiwgc2Qpe1xyXG4vLyAgICAgICByZXR1cm4gLTAuNSoobWF0aC5lcmYoKG1lYW4teDIpLyhtYXRoLnNxcnQoMikqc2QpKSAtIG1hdGguZXJmKChtZWFuLXgxKS8obWF0aC5zcXJ0KDIpKnNkKSkpO1xyXG4vLyAgICAgfVxyXG5cclxuXHJcbi8vICAgICBjb25zdCB3aWR0aCAgPSB3aW5kb3cuaW5uZXJXaWR0aCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGggfHwgZG9jdW1lbnQuYm9keS5jbGllbnRXaWR0aDtcclxuLy8gICAgIGlmICh3aWR0aCA8PSAxMDAwKXtcclxuLy8gICAgICAgbGluZUNoYXJ0Lm9wdGlvbnMuYW5ub3RhdGlvbi5hbm5vdGF0aW9uc1swXS5sYWJlbFsnZW5hYmxlZCddID0gdHJ1ZTtcclxuLy8gICAgICAgbGluZUNoYXJ0Lm9wdGlvbnMuYW5ub3RhdGlvbi5hbm5vdGF0aW9uc1sxXS5sYWJlbFsnZW5hYmxlZCddID0gdHJ1ZTtcclxuLy8gICAgICAgbGluZUNoYXJ0LnVwZGF0ZSgpO1xyXG4vLyAgICAgfVxyXG4vLyAgICAgKi9cclxuXHRcclxuXHRcclxuLy8gICAgIC8qXHJcbi8vICAgICBCYXllcyBGYWN0b3IgPSBMaWtlbGlob29kIFJhdGlvID0gU2Vuc2l0aXZpdHkgLyBGYWxzZSBQb3NpdGl2ZSBSYXRlXHJcbi8vICAgICAqL1xyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/welchs.js\n");

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ /* webpack/runtime/getFullHash */
/******/ !function() {
/******/ 	__webpack_require__.h = function() { return "aa435c1107b4e742"; }
/******/ }();
/******/ 
/******/ }
);