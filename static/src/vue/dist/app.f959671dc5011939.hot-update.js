"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(typeof self !== 'undefined' ? self : this)["webpackHotUpdatevueapp"]("app",{

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-40.use[0]!./node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./src/components/SliderChartComponent.vue?vue&type=script&lang=js&":
/*!****************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-40.use[0]!./node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./src/components/SliderChartComponent.vue?vue&type=script&lang=js& ***!
  \****************************************************************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _store_store__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../store/store */ \"./src/store/store.js\");\n/* harmony import */ var chart_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! chart.js */ \"./node_modules/chart.js/dist/Chart.js\");\n/* harmony import */ var chart_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(chart_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var chartjs_plugin_annotation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! chartjs-plugin-annotation */ \"./node_modules/chartjs-plugin-annotation/src/index.js\");\n/* harmony import */ var chartjs_plugin_annotation__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(chartjs_plugin_annotation__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var mathjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! mathjs */ \"./node_modules/mathjs/lib/esm/entry/pureFunctionsAny.generated.js\");\n/* harmony import */ var _ttest_chart_data_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../ttest-chart-data.js */ \"./src/ttest-chart-data.js\");\n/* harmony import */ var _welchs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/welchs */ \"./src/welchs.js\");\n\n // npm install chart.js@2.9.4, then tried 2.9.3. so,e say 2.9.4 doesn't work.\n // npm install chartjs-plugin-annotation@0.5.7 --save    <<< used this. necessary?\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  name: 'SliderChart',\n  data() {\n    return {\n      store: _store_store__WEBPACK_IMPORTED_MODULE_0__[\"default\"],\n      ttestChartData: _ttest_chart_data_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"],\n      storecount: _store_store__WEBPACK_IMPORTED_MODULE_0__[\"default\"].state.count,\n      ttestChart: null,\n      thumb: null,\n      sliderValue: null,\n      sliderElem: null\n    };\n  },\n  methods: {\n    drawAlphaCurve: function (group1, crit_t_value) {\n      let alpha_curve = _welchs__WEBPACK_IMPORTED_MODULE_4__[\"default\"].getAlphaCurve(group1, crit_t_value);\n      this.ttestChartData.data.datasets[3].data = alpha_curve; // was [3]['data']\n      // this.ttestChart.update();\n    },\n\n    drawBetaCurve: function (group2, crit_t_value, ncp) {\n      let beta_curve = _welchs__WEBPACK_IMPORTED_MODULE_4__[\"default\"].getBetaCurve(group2, crit_t_value, ncp);\n      this.ttestChartData.data.datasets[4].data = beta_curve;\n      // this.ttestChart.update();\n    },\n\n    convertChartXToScreenX: function (x, chart_x_min, chart_x_max, x1, x2, offset) {\n      //return math.round((((x - chart_x_min)/(chart_x_max - chart_x_min))*(x2-x1)) - offset,0);\n      return (x - chart_x_min) / (chart_x_max - chart_x_min) * (x2 - x1) - offset;\n    },\n    convertScreenXToChartX: function (x, x1, x2, chart_x1, chart_x2, thumbOffsetWidth) {\n      return (x + thumbOffsetWidth / 2) / (x2 - x1) * (chart_x2 - chart_x1) + chart_x1;\n    },\n    convertRangeSliderXToChartX: function (rs_x, rs_x1, rs_x2, px_x1, px_x2, chart_x1, chart_x2, thumbWidth) {\n      let rs_prop = rs_x / (rs_x2 - rs_x1);\n      console.log(\"rs_prop\", rs_prop);\n      let px_offset = -(rs_prop - 0.5) * Number(thumbWidth);\n      console.log(\"px_offset\", px_offset);\n      let px_prop = rs_prop + px_offset / (px_x2 - px_x1);\n      console.log(\"px_prop\", px_prop);\n      return px_prop * (chart_x2 - chart_x1) + chart_x1;\n    },\n    slidefunc() {\n      console.log(\"SLIDEFUNC\", this.store.state.axes.x_min, this.store.state.axes.x_max);\n      console.log(\"this.slideValue:\", Number(this.slideValue));\n      var points = this.ttestChart.chart.getDatasetMeta(0).data;\n      var x1 = Number(points[0]._model.x);\n      var x2 = Number(points[1]._model.x);\n      let slideval = Number(this.slideValue);\n      let thumbWidth = 21;\n      this.store.state.crit_t_value = this.convertRangeSliderXToChartX(slideval, 0, 100, x1, x2, this.store.state.axes.x_min, this.store.state.axes.x_max, thumbWidth);\n      console.log(\"CONVERT:\", this.store.state.crit_t_value);\n      // this.ttestChartData.options.annotation.annotations[1].value = this.store.state.crit_t_value;\n      this.updateState();\n      // this.ttestChart.update();\n    },\n\n    updateState: function () {\n      //updateState: function(crit_t_value, df, ncp)\n      // calculations\n      // crit_t_value_beta = crit_t_value - ncp;  // ncp: non-centrality parameter\n      // alpha = getAlpha(crit_t_value, df);\n      // beta = getBeta(crit_t_value_beta, df);\n\n      // UPDATE STATE IN STORE\n\n      this.store.state.alpha = mathjs__WEBPACK_IMPORTED_MODULE_5__.round(_welchs__WEBPACK_IMPORTED_MODULE_4__[\"default\"].getAlpha(this.store.state.crit_t_value, this.store.state.df), 4);\n      this.store.state.beta = mathjs__WEBPACK_IMPORTED_MODULE_5__.round(_welchs__WEBPACK_IMPORTED_MODULE_4__[\"default\"].getBeta(this.store.state.crit_t_value_beta, this.store.state.df), 4);\n      console.log(\"crit_t_value:\", this.store.state.crit_t_value);\n      console.log(\"crit_t_value_beta:\", this.store.state.crit_t_value_beta);\n      console.log(\"df:\", this.store.state.df);\n      console.log(\"alpha:\", this.store.state.alpha);\n      console.log(\"beta:\", this.store.state.beta);\n\n      // // update display\n      // elem('crit_t_value').innerText = crit_t_value;\n      // elem('sig-level').innerText = round(alpha);\n\n      this.ttestChartData.options.annotation.annotations[1].value = this.store.state.crit_t_value;\n      // lineChart.options.annotation.annotations[1]['value'] = crit_t_value;\n      // lineChart.update();\n\n      // drawAlphaCurve(group1, crit_t_value);\n      // drawBetaCurve(group2, crit_t_value);\n      this.drawAlphaCurve(this.store.state.group1, this.store.state.crit_t_value);\n      this.drawBetaCurve(this.store.state.group2, this.store.state.crit_t_value, this.store.state.ncp);\n\n      // updateConfusionMatrix(alpha, beta);\n      // showRejectOrNotReject(crit_t_value, t_value);\n      // updateProbabilityTree();\n      this.ttestChart.update();\n      // store.commit('updateState');\n    },\n\n    initThumb() {\n      var points = this.ttestChart.chart.getDatasetMeta(0).data;\n      var x1 = points[0]._model.x;\n      var x2 = points[1]._model.x;\n      this.sliderElem.style.left = x1 + \"px\";\n      this.sliderElem.style.width = x2 - x1 + \"px\";\n    }\n  },\n  // computed: {\n  //   computedLeft: function () {\n  //     return \"51px\";\n  //   },\n  // },\n  mounted() {\n    chart_js__WEBPACK_IMPORTED_MODULE_1___default().plugins.register((chartjs_plugin_annotation__WEBPACK_IMPORTED_MODULE_2___default()));\n    this.ttestChart = new (chart_js__WEBPACK_IMPORTED_MODULE_1___default())(document.getElementById('ttest-chart'), this.ttestChartData);\n    this.ttestChartData.data.datasets[0].data = [{\n      x: -4.753,\n      y: 0\n    }, {\n      x: 7.232,\n      y: 0\n    }];\n    this.ttestChartData.options.scales.xAxes[0].ticks.min = this.store.state.axes.min;\n    this.ttestChartData.options.scales.xAxes[0].ticks.max = this.store.state.axes.max;\n    this.ttestChartData.options.scales.yAxes[0].ticks.max = 0.5;\n    this.ttestChartData.options.annotation.annotations[0].label.content = 'p = ' + this.store.state.p_value;\n    this.ttestChartData.options.annotation.annotations[0].value = this.store.state.t_value;\n    this.ttestChartData.options.annotation.annotations[1].content = '\\u03B1' + this.store.state.alpha;\n    this.ttestChartData.options.annotation.annotations[1].value = this.store.state.crit_t_value;\n    this.ttestChartData.data.datasets[1].data = this.store.state.group1.dist;\n    this.ttestChartData.data.datasets[2].data = this.store.state.group2.dist;\n    this.updateState();\n    this.sliderElem = document.getElementById('myRange');\n    this.initThumb();\n\n    // init range slider annotation position\n    this.slideValue = 50;\n    this.slidefunc();\n  }\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8/Y2xvbmVkUnVsZVNldC00MC51c2VbMF0hLi9ub2RlX21vZHVsZXMvQHZ1ZS92dWUtbG9hZGVyLXYxNS9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3NyYy9jb21wb25lbnRzL1NsaWRlckNoYXJ0Q29tcG9uZW50LnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyYuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBbUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBSUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWVhcHAvc3JjL2NvbXBvbmVudHMvU2xpZGVyQ2hhcnRDb21wb25lbnQudnVlPzU0NDgiXSwic291cmNlc0NvbnRlbnQiOlsiXG48dGVtcGxhdGU+XG4gIDxkaXY+XG5cbiAgICA8ZGl2IGNsYXNzPVwic2xpZGVjb250YWluZXJcIiBpZD1cInNsaWRlY29udGFpbmVyXCI+XG4gICAgICA8aW5wdXQgdHlwZT1cInJhbmdlXCIgbWluPVwiMFwiIG1heD1cIjEwMFwiIHZhbHVlPVwiNTBcIiBjbGFzcz1cInNsaWRlclwiIGlkPVwibXlSYW5nZVwiIHYtbW9kZWw9XCJzbGlkZVZhbHVlXCIgdi1vbjppbnB1dD1cInNsaWRlZnVuY1wiPlxuICAgICAgPCEtLSA8aW5wdXQgdHlwZT1cInJhbmdlXCIgbWluPVwiMFwiIG1heD1cIjEwMFwiIHZhbHVlPVwiNTBcIiBjbGFzcz1cInNsaWRlclwiIGlkPVwibXlSYW5nZVwiIHYtbW9kZWw9XCJzbGlkZVZhbHVlXCIgdi1vbjppbnB1dD1cInNsaWRlZnVuY1wiIHYtYmluZDpzdHlsZT1cInsgbGVmdDogY29tcHV0ZWRMZWZ0IH1cIj4gLS0+XG4gICAgPC9kaXY+XG5cbiAgICA8ZGl2PlxuICAgICAgPGNhbnZhcyBpZD1cInR0ZXN0LWNoYXJ0XCIgd2lkdGg9XCIxMDAwXCIgaGVpZ2h0PVwiODAwXCI+PC9jYW52YXM+XG4gICAgPC9kaXY+XG5cblxuICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cblxuPHNjcmlwdD5cbmltcG9ydCBzdG9yZSBmcm9tICcuLi9zdG9yZS9zdG9yZScgXG5pbXBvcnQgQ2hhcnQgZnJvbSAnY2hhcnQuanMnICAvLyBucG0gaW5zdGFsbCBjaGFydC5qc0AyLjkuNCwgdGhlbiB0cmllZCAyLjkuMy4gc28sZSBzYXkgMi45LjQgZG9lc24ndCB3b3JrLlxuaW1wb3J0IGNoYXJ0anNQbHVnaW5Bbm5vdGF0aW9uIGZyb20gXCJjaGFydGpzLXBsdWdpbi1hbm5vdGF0aW9uXCI7IC8vIG5wbSBpbnN0YWxsIGNoYXJ0anMtcGx1Z2luLWFubm90YXRpb25AMC41LjcgLS1zYXZlICAgIDw8PCB1c2VkIHRoaXMuIG5lY2Vzc2FyeT9cbmltcG9ydCAqIGFzIG1hdGggZnJvbSAnbWF0aGpzJztcbmltcG9ydCB0dGVzdENoYXJ0RGF0YSBmcm9tICcuLi90dGVzdC1jaGFydC1kYXRhLmpzJ1xuaW1wb3J0IHdlbGNocyBmcm9tICdAL3dlbGNocyc7XG5cblxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdTbGlkZXJDaGFydCcsXG4gIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0b3JlLFxuICAgICAgdHRlc3RDaGFydERhdGE6IHR0ZXN0Q2hhcnREYXRhLFxuICAgICAgc3RvcmVjb3VudDogc3RvcmUuc3RhdGUuY291bnQsXG4gICAgICB0dGVzdENoYXJ0OiBudWxsLFxuICAgICAgdGh1bWI6IG51bGwsXG4gICAgICBzbGlkZXJWYWx1ZTogbnVsbCxcbiAgICAgIHNsaWRlckVsZW06IG51bGwsXG4gICAgfVxuICB9LFxuICBtZXRob2RzOiB7XG4gICAgZHJhd0FscGhhQ3VydmU6IGZ1bmN0aW9uKGdyb3VwMSwgY3JpdF90X3ZhbHVlKXsgIFxuICAgICAgbGV0IGFscGhhX2N1cnZlID0gd2VsY2hzLmdldEFscGhhQ3VydmUoZ3JvdXAxLCBjcml0X3RfdmFsdWUpO1xuICAgICAgdGhpcy50dGVzdENoYXJ0RGF0YS5kYXRhLmRhdGFzZXRzWzNdLmRhdGEgPSBhbHBoYV9jdXJ2ZTsgIC8vIHdhcyBbM11bJ2RhdGEnXVxuICAgICAgLy8gdGhpcy50dGVzdENoYXJ0LnVwZGF0ZSgpO1xuICAgIH0sXG4gICAgZHJhd0JldGFDdXJ2ZTogZnVuY3Rpb24gKGdyb3VwMiwgY3JpdF90X3ZhbHVlLCBuY3ApeyAgXG4gICAgICBsZXQgYmV0YV9jdXJ2ZSA9IHdlbGNocy5nZXRCZXRhQ3VydmUgKGdyb3VwMiwgY3JpdF90X3ZhbHVlLCBuY3ApO1xuICAgICAgdGhpcy50dGVzdENoYXJ0RGF0YS5kYXRhLmRhdGFzZXRzWzRdLmRhdGEgPSBiZXRhX2N1cnZlO1xuICAgICAgLy8gdGhpcy50dGVzdENoYXJ0LnVwZGF0ZSgpO1xuICAgIH0sXG5cbiAgICBjb252ZXJ0Q2hhcnRYVG9TY3JlZW5YOiBmdW5jdGlvbiAoeCwgY2hhcnRfeF9taW4sIGNoYXJ0X3hfbWF4LCB4MSwgeDIsIG9mZnNldCl7XG4gICAgLy9yZXR1cm4gbWF0aC5yb3VuZCgoKCh4IC0gY2hhcnRfeF9taW4pLyhjaGFydF94X21heCAtIGNoYXJ0X3hfbWluKSkqKHgyLXgxKSkgLSBvZmZzZXQsMCk7XG4gICAgcmV0dXJuICgoKHggLSBjaGFydF94X21pbikvKGNoYXJ0X3hfbWF4IC0gY2hhcnRfeF9taW4pKSooeDIteDEpKSAtIG9mZnNldDtcbiAgICB9LFxuXG4gICAgY29udmVydFNjcmVlblhUb0NoYXJ0WDogZnVuY3Rpb24gKHgsIHgxLCB4MiwgY2hhcnRfeDEsIGNoYXJ0X3gyLCB0aHVtYk9mZnNldFdpZHRoKXtcbiAgICAgIHJldHVybiAoeCArICh0aHVtYk9mZnNldFdpZHRoLzIpKS8oeDIgLSB4MSkqKGNoYXJ0X3gyLWNoYXJ0X3gxKSArIGNoYXJ0X3gxO1xuICAgIH0sXG5cbiAgICBjb252ZXJ0UmFuZ2VTbGlkZXJYVG9DaGFydFg6IGZ1bmN0aW9uIChyc194LCByc194MSwgcnNfeDIsIHB4X3gxLCBweF94MiwgY2hhcnRfeDEsIGNoYXJ0X3gyLCB0aHVtYldpZHRoKXtcbiAgICAgIGxldCByc19wcm9wID0gcnNfeC8ocnNfeDItcnNfeDEpO1xuICAgICAgY29uc29sZS5sb2coXCJyc19wcm9wXCIsIHJzX3Byb3ApO1xuICAgICAgbGV0IHB4X29mZnNldCA9IC0ocnNfcHJvcC0wLjUpKk51bWJlcih0aHVtYldpZHRoKTsgXG4gICAgICBjb25zb2xlLmxvZyhcInB4X29mZnNldFwiLCBweF9vZmZzZXQpO1xuICAgICAgbGV0IHB4X3Byb3AgPSByc19wcm9wICsgcHhfb2Zmc2V0LyhweF94Mi1weF94MSk7XG4gICAgICBjb25zb2xlLmxvZyhcInB4X3Byb3BcIiwgcHhfcHJvcCk7XG4gICAgICByZXR1cm4gIHB4X3Byb3AqKGNoYXJ0X3gyLWNoYXJ0X3gxKSArIGNoYXJ0X3gxO1xuICAgIH0sXG5cblxuICAgIHNsaWRlZnVuYygpe1xuICAgICAgY29uc29sZS5sb2coXCJTTElERUZVTkNcIiwgdGhpcy5zdG9yZS5zdGF0ZS5heGVzLnhfbWluLCB0aGlzLnN0b3JlLnN0YXRlLmF4ZXMueF9tYXgpO1xuICAgICAgY29uc29sZS5sb2coXCJ0aGlzLnNsaWRlVmFsdWU6XCIsIE51bWJlcih0aGlzLnNsaWRlVmFsdWUpKTtcbiAgICAgIHZhciBwb2ludHMgPSB0aGlzLnR0ZXN0Q2hhcnQuY2hhcnQuZ2V0RGF0YXNldE1ldGEoMCkuZGF0YTtcbiAgICAgIHZhciB4MSA9IE51bWJlcihwb2ludHNbMF0uX21vZGVsLngpO1xuICAgICAgdmFyIHgyID0gTnVtYmVyKHBvaW50c1sxXS5fbW9kZWwueCk7XG4gICAgICBsZXQgc2xpZGV2YWwgPSBOdW1iZXIodGhpcy5zbGlkZVZhbHVlKTtcbiAgICAgIGxldCB0aHVtYldpZHRoID0gMjE7XG4gICAgICB0aGlzLnN0b3JlLnN0YXRlLmNyaXRfdF92YWx1ZSA9IHRoaXMuY29udmVydFJhbmdlU2xpZGVyWFRvQ2hhcnRYKHNsaWRldmFsLCAwLCAxMDAsIHgxLCB4MiwgdGhpcy5zdG9yZS5zdGF0ZS5heGVzLnhfbWluLCB0aGlzLnN0b3JlLnN0YXRlLmF4ZXMueF9tYXgsIHRodW1iV2lkdGgpOyBcbiAgICAgIGNvbnNvbGUubG9nKFwiQ09OVkVSVDpcIiwgdGhpcy5zdG9yZS5zdGF0ZS5jcml0X3RfdmFsdWUpO1xuICAgICAgLy8gdGhpcy50dGVzdENoYXJ0RGF0YS5vcHRpb25zLmFubm90YXRpb24uYW5ub3RhdGlvbnNbMV0udmFsdWUgPSB0aGlzLnN0b3JlLnN0YXRlLmNyaXRfdF92YWx1ZTtcbiAgICAgIHRoaXMudXBkYXRlU3RhdGUoKTtcbiAgICAgIC8vIHRoaXMudHRlc3RDaGFydC51cGRhdGUoKTtcbiAgICB9LFxuICAgIFxuICAgIHVwZGF0ZVN0YXRlOiBmdW5jdGlvbigpeyAgLy91cGRhdGVTdGF0ZTogZnVuY3Rpb24oY3JpdF90X3ZhbHVlLCBkZiwgbmNwKVxuICAgICAgLy8gY2FsY3VsYXRpb25zXG4gICAgICAvLyBjcml0X3RfdmFsdWVfYmV0YSA9IGNyaXRfdF92YWx1ZSAtIG5jcDsgIC8vIG5jcDogbm9uLWNlbnRyYWxpdHkgcGFyYW1ldGVyXG4gICAgICAvLyBhbHBoYSA9IGdldEFscGhhKGNyaXRfdF92YWx1ZSwgZGYpO1xuICAgICAgLy8gYmV0YSA9IGdldEJldGEoY3JpdF90X3ZhbHVlX2JldGEsIGRmKTtcblxuICAgICAgLy8gVVBEQVRFIFNUQVRFIElOIFNUT1JFXG5cbiAgICAgIHRoaXMuc3RvcmUuc3RhdGUuYWxwaGEgPSBtYXRoLnJvdW5kKHdlbGNocy5nZXRBbHBoYSh0aGlzLnN0b3JlLnN0YXRlLmNyaXRfdF92YWx1ZSwgdGhpcy5zdG9yZS5zdGF0ZS5kZiksIDQpO1xuICAgICAgdGhpcy5zdG9yZS5zdGF0ZS5iZXRhID0gbWF0aC5yb3VuZCh3ZWxjaHMuZ2V0QmV0YSh0aGlzLnN0b3JlLnN0YXRlLmNyaXRfdF92YWx1ZV9iZXRhLCB0aGlzLnN0b3JlLnN0YXRlLmRmKSwgNCk7XG5cbiAgICAgIGNvbnNvbGUubG9nKFwiY3JpdF90X3ZhbHVlOlwiLCB0aGlzLnN0b3JlLnN0YXRlLmNyaXRfdF92YWx1ZSk7XG4gICAgICBjb25zb2xlLmxvZyhcImNyaXRfdF92YWx1ZV9iZXRhOlwiLCB0aGlzLnN0b3JlLnN0YXRlLmNyaXRfdF92YWx1ZV9iZXRhKTtcbiAgICAgIGNvbnNvbGUubG9nKFwiZGY6XCIsIHRoaXMuc3RvcmUuc3RhdGUuZGYpO1xuICAgICAgY29uc29sZS5sb2coXCJhbHBoYTpcIiwgdGhpcy5zdG9yZS5zdGF0ZS5hbHBoYSk7XG4gICAgICBjb25zb2xlLmxvZyhcImJldGE6XCIsIHRoaXMuc3RvcmUuc3RhdGUuYmV0YSk7XG5cbiAgICAgIC8vIC8vIHVwZGF0ZSBkaXNwbGF5XG4gICAgICAvLyBlbGVtKCdjcml0X3RfdmFsdWUnKS5pbm5lclRleHQgPSBjcml0X3RfdmFsdWU7XG4gICAgICAvLyBlbGVtKCdzaWctbGV2ZWwnKS5pbm5lclRleHQgPSByb3VuZChhbHBoYSk7XG5cbiAgICAgIHRoaXMudHRlc3RDaGFydERhdGEub3B0aW9ucy5hbm5vdGF0aW9uLmFubm90YXRpb25zWzFdLnZhbHVlID0gdGhpcy5zdG9yZS5zdGF0ZS5jcml0X3RfdmFsdWU7XG4gICAgICAvLyBsaW5lQ2hhcnQub3B0aW9ucy5hbm5vdGF0aW9uLmFubm90YXRpb25zWzFdWyd2YWx1ZSddID0gY3JpdF90X3ZhbHVlO1xuICAgICAgLy8gbGluZUNoYXJ0LnVwZGF0ZSgpO1xuXG4gICAgICAvLyBkcmF3QWxwaGFDdXJ2ZShncm91cDEsIGNyaXRfdF92YWx1ZSk7XG4gICAgICAvLyBkcmF3QmV0YUN1cnZlKGdyb3VwMiwgY3JpdF90X3ZhbHVlKTtcbiAgICAgIHRoaXMuZHJhd0FscGhhQ3VydmUodGhpcy5zdG9yZS5zdGF0ZS5ncm91cDEsIHRoaXMuc3RvcmUuc3RhdGUuY3JpdF90X3ZhbHVlKTtcbiAgICAgIHRoaXMuZHJhd0JldGFDdXJ2ZSh0aGlzLnN0b3JlLnN0YXRlLmdyb3VwMiwgdGhpcy5zdG9yZS5zdGF0ZS5jcml0X3RfdmFsdWUsdGhpcy5zdG9yZS5zdGF0ZS5uY3ApO1xuICAgICAgXG4gICAgICAvLyB1cGRhdGVDb25mdXNpb25NYXRyaXgoYWxwaGEsIGJldGEpO1xuICAgICAgLy8gc2hvd1JlamVjdE9yTm90UmVqZWN0KGNyaXRfdF92YWx1ZSwgdF92YWx1ZSk7XG4gICAgICAvLyB1cGRhdGVQcm9iYWJpbGl0eVRyZWUoKTtcbiAgICAgIHRoaXMudHRlc3RDaGFydC51cGRhdGUoKTtcbiAgICAgIC8vIHN0b3JlLmNvbW1pdCgndXBkYXRlU3RhdGUnKTtcblxuICAgIH0sXG5cbiAgICBpbml0VGh1bWIoKXtcbiAgICAgIHZhciBwb2ludHMgPSB0aGlzLnR0ZXN0Q2hhcnQuY2hhcnQuZ2V0RGF0YXNldE1ldGEoMCkuZGF0YTtcbiAgICAgIHZhciB4MSA9IHBvaW50c1swXS5fbW9kZWwueDtcbiAgICAgIHZhciB4MiA9IHBvaW50c1sxXS5fbW9kZWwueDtcbiAgICAgIHRoaXMuc2xpZGVyRWxlbS5zdHlsZS5sZWZ0ID0geDEgKyBcInB4XCI7XG4gICAgICB0aGlzLnNsaWRlckVsZW0uc3R5bGUud2lkdGggPSB4MiAtIHgxICsgXCJweFwiO1xuICAgIH0sXG5cbiAgfSxcbiAgLy8gY29tcHV0ZWQ6IHtcbiAgLy8gICBjb21wdXRlZExlZnQ6IGZ1bmN0aW9uICgpIHtcbiAgLy8gICAgIHJldHVybiBcIjUxcHhcIjtcbiAgLy8gICB9LFxuICAvLyB9LFxuICBtb3VudGVkKCkge1xuICAgIENoYXJ0LnBsdWdpbnMucmVnaXN0ZXIoY2hhcnRqc1BsdWdpbkFubm90YXRpb24pXG4gICAgdGhpcy50dGVzdENoYXJ0ID0gbmV3IENoYXJ0KGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd0dGVzdC1jaGFydCcpLCB0aGlzLnR0ZXN0Q2hhcnREYXRhKTtcbiAgICB0aGlzLnR0ZXN0Q2hhcnREYXRhLmRhdGEuZGF0YXNldHNbMF0uZGF0YSA9IFt7eDogLTQuNzUzLCB5OiAwfSwge3g6IDcuMjMyLCB5OiAwfV07XG4gICAgdGhpcy50dGVzdENoYXJ0RGF0YS5vcHRpb25zLnNjYWxlcy54QXhlc1swXS50aWNrcy5taW4gPSB0aGlzLnN0b3JlLnN0YXRlLmF4ZXMubWluO1xuICAgIHRoaXMudHRlc3RDaGFydERhdGEub3B0aW9ucy5zY2FsZXMueEF4ZXNbMF0udGlja3MubWF4ID0gdGhpcy5zdG9yZS5zdGF0ZS5heGVzLm1heDsgXG4gICAgdGhpcy50dGVzdENoYXJ0RGF0YS5vcHRpb25zLnNjYWxlcy55QXhlc1swXS50aWNrcy5tYXggPSAwLjU7XG5cbiAgICB0aGlzLnR0ZXN0Q2hhcnREYXRhLm9wdGlvbnMuYW5ub3RhdGlvbi5hbm5vdGF0aW9uc1swXS5sYWJlbC5jb250ZW50ID0gJ3AgPSAnICsgdGhpcy5zdG9yZS5zdGF0ZS5wX3ZhbHVlO1xuICAgIHRoaXMudHRlc3RDaGFydERhdGEub3B0aW9ucy5hbm5vdGF0aW9uLmFubm90YXRpb25zWzBdLnZhbHVlID0gdGhpcy5zdG9yZS5zdGF0ZS50X3ZhbHVlO1xuICAgIHRoaXMudHRlc3RDaGFydERhdGEub3B0aW9ucy5hbm5vdGF0aW9uLmFubm90YXRpb25zWzFdLmNvbnRlbnQgPSAnXFx1MDNCMScgKyB0aGlzLnN0b3JlLnN0YXRlLmFscGhhOyBcbiAgICB0aGlzLnR0ZXN0Q2hhcnREYXRhLm9wdGlvbnMuYW5ub3RhdGlvbi5hbm5vdGF0aW9uc1sxXS52YWx1ZSA9IHRoaXMuc3RvcmUuc3RhdGUuY3JpdF90X3ZhbHVlO1xuICAgIFxuICAgIHRoaXMudHRlc3RDaGFydERhdGEuZGF0YS5kYXRhc2V0c1sxXS5kYXRhID0gdGhpcy5zdG9yZS5zdGF0ZS5ncm91cDEuZGlzdDtcbiAgICB0aGlzLnR0ZXN0Q2hhcnREYXRhLmRhdGEuZGF0YXNldHNbMl0uZGF0YSA9IHRoaXMuc3RvcmUuc3RhdGUuZ3JvdXAyLmRpc3Q7XG4gICAgdGhpcy51cGRhdGVTdGF0ZSgpO1xuICAgIFxuICAgIFxuICAgIHRoaXMuc2xpZGVyRWxlbSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdteVJhbmdlJyk7XG4gICAgdGhpcy5pbml0VGh1bWIoKTtcblxuICAgIC8vIGluaXQgcmFuZ2Ugc2xpZGVyIGFubm90YXRpb24gcG9zaXRpb25cbiAgICB0aGlzLnNsaWRlVmFsdWU9NTA7XG4gICAgdGhpcy5zbGlkZWZ1bmMoKTtcblxuICB9LFxuXG5cblxufVxuPC9zY3JpcHQ+XG5cblxuXG5cbjxzdHlsZSBzY29wZWQ+XG5cbiAgLnNsaWRlY29udGFpbmVyIHtcbiAgICBtYXJnaW46IDBweDtcbiAgICBwYWRkaW5nOiAwcHg7XG4gIH1cblxuICAvKiBUaGUgc2xpZGVyIGl0c2VsZiAqL1xuICAuc2xpZGVyIHtcbiAgICAtd2Via2l0LWFwcGVhcmFuY2U6IG5vbmU7ICAvKiBPdmVycmlkZSBkZWZhdWx0IENTUyBzdHlsZXMgKi9cbiAgICBhcHBlYXJhbmNlOiBub25lO1xuICAgIHdpZHRoOiAxMDAlOyAvKiBGdWxsLXdpZHRoICovXG4gICAgaGVpZ2h0OiAxNXB4OyAvKiBTcGVjaWZpZWQgaGVpZ2h0ICovXG4gICAgYmFja2dyb3VuZDogI2QzZDNkMzsgLyogR3JleSBiYWNrZ3JvdW5kICovXG4gICAgb3V0bGluZTogbm9uZTsgLyogUmVtb3ZlIG91dGxpbmUgKi9cbiAgICAvKm9wYWNpdHk6IDAuNzsqLyAvKiBTZXQgdHJhbnNwYXJlbmN5IChmb3IgbW91c2Utb3ZlciBlZmZlY3RzIG9uIGhvdmVyKSAqL1xuICAgIC13ZWJraXQtdHJhbnNpdGlvbjogLjJzOyAvKiAwLjIgc2Vjb25kcyB0cmFuc2l0aW9uIG9uIGhvdmVyICovXG4gICAgdHJhbnNpdGlvbjogb3BhY2l0eSAuMnM7XG4gICAgYm9yZGVyLXJhZGl1czogM3B4O1xuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICBtYXJnaW46IDBweDtcbiAgICBwYWRkaW5nOiAwcHg7XG4gICAgdG9wOiArNXB4O1xuXG4gIH1cbiAgLyogLnNsaWRlciB7XG4gICAgYm9yZGVyLXJhZGl1czogNXB4O1xuICAgIGJhY2tncm91bmQ6ICNFMEUwRTA7XG4gICAgYmFja2dyb3VuZDogbGluZWFyLWdyYWRpZW50KGxlZnQgdG9wLCAjRTBFMEUwLCAjRUVFRUVFKTtcbiAgICBoZWlnaHQ6IDE1cHg7XG4gICAgbWFyZ2luOiAwcHg7XG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICB9ICovXG5cblxuICAvKiBNb3VzZS1vdmVyIGVmZmVjdHMgKi9cbiAgLnNsaWRlcjpob3ZlciB7XG4gICAgb3BhY2l0eTogMTsgLyogRnVsbHkgc2hvd24gb24gbW91c2Utb3ZlciAqL1xuICB9XG5cbiAgLyogVGhlIHNsaWRlciBoYW5kbGUgKHVzZSAtd2Via2l0LSAoQ2hyb21lLCBPcGVyYSwgU2FmYXJpLCBFZGdlKSBhbmQgLW1vei0gKEZpcmVmb3gpIHRvIG92ZXJyaWRlIGRlZmF1bHQgbG9vaykgKi9cbiAgLnNsaWRlcjo6LXdlYmtpdC1zbGlkZXItdGh1bWIge1xuICAgIC13ZWJraXQtYXBwZWFyYW5jZTogbm9uZTsgLyogT3ZlcnJpZGUgZGVmYXVsdCBsb29rICovXG4gICAgYXBwZWFyYW5jZTogbm9uZTtcbiAgICB3aWR0aDogMjFweDsgLyogU2V0IGEgc3BlY2lmaWMgc2xpZGVyIGhhbmRsZSB3aWR0aCAqL1xuICAgIGhlaWdodDogMjVweDsgLyoyNXB4ICAgU2xpZGVyIGhhbmRsZSBoZWlnaHQgKi9cbiAgICBjdXJzb3I6IHBvaW50ZXI7IC8qIEN1cnNvciBvbiBob3ZlciAqL1xuICAgIG9wYWNpdHk6IDE7XG4gICAgYmFja2dyb3VuZDogI2ZmM2UwMDtcbiAgICBib3JkZXItcmFkaXVzOiAzcHg7XG4gICAgLyogdG9wOiAtNXB4OyAqL1xuICAgIC8qIGJvdHRvbTogLTJweDsgKi9cbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgbWFyZ2luOiAwcHg7XG4gICAgcGFkZGluZzogMHB4O1xuICAgIGxlZnQ6IDBweDtcblxuICB9XG5cbiAgLnNsaWRlcjo6LW1vei1yYW5nZS10aHVtYiB7XG4gICAgd2lkdGg6IDE1cHg7IC8qIFNldCBhIHNwZWNpZmljIHNsaWRlciBoYW5kbGUgd2lkdGggKi9cbiAgICBoZWlnaHQ6IDI1cHg7IC8qIFNsaWRlciBoYW5kbGUgaGVpZ2h0ICovXG4gICAgY3Vyc29yOiBwb2ludGVyOyAvKiBDdXJzb3Igb24gaG92ZXIgKi9cblxuICAgIGJhY2tncm91bmQ6ICNmZjNlMDA7XG4gICAgYm9yZGVyLXJhZGl1czogM3B4O1xuICB9XG5cblxuXG4gIC50aHVtYiB7XG4gICAgd2lkdGg6IDE1cHg7XG4gICAgaGVpZ2h0OiAyNXB4O1xuICAgIGJvcmRlci1yYWRpdXM6IDNweDtcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgbGVmdDogMHB4O1xuICAgIHRvcDogLTVweDtcbiAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgYmFja2dyb3VuZDogI2ZmM2UwMDtcbiAgfVxuXG4gIC8qICNhcHAge1xuICAgIGZvbnQtZmFtaWx5OiBBdmVuaXIsIEhlbHZldGljYSwgQXJpYWwsIHNhbnMtc2VyaWY7XG4gICAgLXdlYmtpdC1mb250LXNtb290aGluZzogYW50aWFsaWFzZWQ7XG4gICAgLW1vei1vc3gtZm9udC1zbW9vdGhpbmc6IGdyYXlzY2FsZTtcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XG4gICAgY29sb3I6ICMyYzNlNTA7XG4gICAgbWFyZ2luLXRvcDogNjBweDtcbiAgfSAqL1xuXG4gIGh0bWwge1xuICAgIHNjcm9sbC1iZWhhdmlvcjogc21vb3RoO1xuICB9XG5cbiAgYm9keSB7XG4gICAgLyogYmFja2dyb3VuZC1jb2xvcjogI2ZmM2UwMDsgKi9cbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjNDM0MzQzO1xuICAgIGZvbnQtZmFtaWx5OiBcIkhlbHZldGljYSBOZXVlXCIsIHNhbnMtc2VyaWY7XG4gICAgZm9udC1zaXplOiAxNXB4O1xuICB9XG5cbiAgYTpsaW5rLCBhOnZpc2l0ZWQge1xuICAgIGNvbG9yOiBncmV5O1xuICAgIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcbiAgfVxuXG4gIC8qIG1vdXNlIG92ZXIgbGluayAqL1xuICBhOmhvdmVyIHtcbiAgICBjb2xvcjogd2hpdGU7XG4gICAgdGV4dC1kZWNvcmF0aW9uOiBub25lO1xuICB9XG5cbiAgLyogc2VsZWN0ZWQgbGluayAqL1xuICBhOmFjdGl2ZSB7XG4gICAgY29sb3I6IGJsYWNrO1xuICAgIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcbiAgfVxuXG5cbiAgaDQge1xuICAgIGZvbnQtZmFtaWx5OiBcIkhlbHZldGljYSBOZXVlXCIsIHNhbnMtc2VyaWY7XG4gIH1cblxuXG4gIC5yZXNwb25zaXZlIHtcbiAgICB3aWR0aDogMTAwJTtcbiAgICBoZWlnaHQ6IGF1dG87XG4gIH1cblxuICAvKiAuc2xpZGVyIHtcbiAgICBib3JkZXItcmFkaXVzOiA1cHg7XG4gICAgYmFja2dyb3VuZDogI0UwRTBFMDtcbiAgICBiYWNrZ3JvdW5kOiBsaW5lYXItZ3JhZGllbnQobGVmdCB0b3AsICNFMEUwRTAsICNFRUVFRUUpO1xuICAgIGhlaWdodDogMTVweDtcbiAgICBtYXJnaW46IDBweDtcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gIH0gKi9cbiAgLyogd2lkdGg6IDUyNXB4OyAqL1xuXG5cbiAgLnRodW1iIHtcbiAgICB3aWR0aDogMTVweDtcbiAgICBoZWlnaHQ6IDI1cHg7XG4gICAgYm9yZGVyLXJhZGl1czogM3B4O1xuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICBsZWZ0OiAwcHg7XG4gICAgdG9wOiAtNXB4O1xuICAgIGJhY2tncm91bmQ6ICNmZjNlMDA7XG4gICAgY3Vyc29yOiBwb2ludGVyO1xuICB9XG5cblxuPC9zdHlsZT5cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/babel-loader/lib/index.js??clonedRuleSet-40.use[0]!./node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./src/components/SliderChartComponent.vue?vue&type=script&lang=js&\n");

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ /* webpack/runtime/getFullHash */
/******/ !function() {
/******/ 	__webpack_require__.h = function() { return "165bf401006e6162"; }
/******/ }();
/******/ 
/******/ }
);