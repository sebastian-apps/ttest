"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(typeof self !== 'undefined' ? self : this)["webpackHotUpdatevueapp"]("app",{

/***/ "./src/welchs.js":
/*!***********************!*\
  !*** ./src/welchs.js ***!
  \***********************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var mathjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! mathjs */ \"./node_modules/mathjs/lib/esm/entry/pureFunctionsAny.generated.js\");\n/* harmony import */ var chart_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! chart.js */ \"./node_modules/chart.js/dist/chart.js\");\n// function drawAlphaCurve(group1, crit_t_value){\n//     // Fill the area under the curve representing alpha.\n//     let alpha_curve = [];\n//     // this datapoint connects with the critical t vertical line\n//     alpha_curve.push({x: crit_t_value, y: t_Distrib(crit_t_value, group1.df)});\n//     for(var i = 0; i < group1.dist.length; i++) {\n//       if (group1.dist[i]['x'] > crit_t_value){\n//         alpha_curve.push({x: group1.dist[i]['x'], y: group1.dist[i]['y']});\n//       }\n//     }\n//     lineChart.data.datasets[3]['data'] = alpha_curve;\n//     lineChart.update();\n//   }\n\n//   function drawBetaCurve(group2, crit_t_value){\n//     // Fill the area under the curve representing beta.\n//     let beta_curve = [];\n//     for(var i = 0; i < group2.dist.length; i++) {\n//       if (group2.dist[i]['x'] < crit_t_value){\n//         beta_curve.push({x: group2.dist[i]['x'], y: group2.dist[i]['y']});\n//       }\n//     }\n//     // this datapoint connects with the critical t vertical line\n//     beta_curve.push({x: crit_t_value, y: t_Distrib(crit_t_value-ncp, group2.df)}); // ncp acts as offset\n//     lineChart.data.datasets[4]['data'] = beta_curve;\n//     lineChart.update();\n//   }\n\n// function t_Distrib(t, dof){\n//   // For a given x, return the t distribution y value.\n//   y = (math.gamma((dof+1)/2)/(math.sqrt(dof*math.pi)*math.gamma(dof/2))) * (1+((t**2)/dof))**(-(dof+1)/2);\n//   return math.round(y, 6);\n// }\n\n// function getAlpha(crit_t_value, df){\n//   return 1 - computeArea(crit_t_value, df);\n// }\n\n// function getBeta(crit_t_value_beta, df){\n//   return computeArea(crit_t_value_beta, df);\n// }\n\n// function getRocCurve(axes){\n//   console.log(\"axes.x_max\", axes.x_max);\n//   console.log(\"axes.x_min:\", axes.x_min);\n//   let partitions = 25;\n//   step_size = (axes.x_max - axes.x_min)/partitions;\n//   console.log(\"step_size:\", step_size);\n//   console.log();\n//   roc_curve=[];\n//   // crit_t_value_beta = crit_t_value - ncp;\n//   for(var i = 0; i <= partitions; i++) {\n//     roc_curve.push({x: getAlpha((axes.x_min+(i*step_size)), df), y: 1-getBeta(((axes.x_min+(i*step_size)))-ncp, df)});    \n//   }\n//   console.log(\"roc_curve:\", roc_curve);\n//   return roc_curve;\n// }\n\n// function getAUC(axes){\n//   // calculate AUC using the left Riemann Sum\n//   console.log(\"axes.x_max\", axes.x_max);\n//   console.log(\"axes.x_min:\", axes.x_min);\n//   let partitions = 500;\n//   let step_size = (axes.x_max - axes.x_min)/partitions;\n//   console.log(\"step_size:\", step_size);\n//   console.log();\n//   let roc_curve=[];\n//   let auc = 0;\n//   for (var i = 0; i <= partitions; i++) {\n//     roc_curve.push({x: getAlpha((axes.x_min+(i*step_size)), df), y: 1-getBeta(((axes.x_min+(i*step_size)))-ncp, df)});    \n//   }\n//   // calculate left Riemann Sum\n//   for (var i = 0; i < roc_curve.length-1; i++) {\n//     auc = auc + (roc_curve[i].x-roc_curve[i+1].x)*roc_curve[i].y;\n//   }\n\n//   console.log(\"auc:\", auc);\n//   return math.round(auc, 2);\n// }\n\n\n\nvar welchs = {\n  // provides shorthand for getting element id\n  elem(elem_id) {\n    return document.getElementById(elem_id);\n  },\n  getFalseDiscoveryRate(FP, TP) {\n    console.log(\"FDR input FP:\", FP);\n    console.log(\"FDR input TP:\", TP);\n    return mathjs__WEBPACK_IMPORTED_MODULE_0__.round(100 * Number(FP) / (Number(FP) + Number(TP)), 2);\n  },\n  // getAlpha(crit_t_value, df){\n  //   return 1 - computeArea(crit_t_value, df);\n  // },\n\n  // getBeta(crit_t_value_beta, df){\n  //   return computeArea(crit_t_value_beta, df);\n  // },\n\n  // getRocCurve(axes, df, ncp){\n  //   console.log(\"axes.x_max\", axes.x_max);\n  //   console.log(\"axes.x_min:\", axes.x_min);\n  //   let partitions = 25;\n  //   step_size = (axes.x_max - axes.x_min)/partitions;\n  //   console.log(\"step_size:\", step_size);\n  //   console.log();\n  //   roc_curve=[];\n  //   // crit_t_value_beta = crit_t_value - ncp;\n  //   for(var i = 0; i <= partitions; i++) {\n  //     roc_curve.push({x: getAlpha((axes.x_min+(i*step_size)), df), y: 1-getBeta(((axes.x_min+(i*step_size)))-ncp, df)});    \n  //   }\n  //   console.log(\"roc_curve:\", roc_curve);\n  //   return roc_curve;\n  // },\n\n  roc_curve: [{\n    x: 0.9995,\n    y: 1\n  }, {\n    x: 0.999,\n    y: 1\n  }, {\n    x: 0.9979,\n    y: 0.9999\n  }, {\n    x: 0.9955,\n    y: 0.9999\n  }, {\n    x: 0.9902,\n    y: 0.9998\n  }, {\n    x: 0.9786,\n    y: 0.9995\n  }, {\n    x: 0.9534,\n    y: 0.9991\n  }, {\n    x: 0.9021,\n    y: 0.9981\n  }, {\n    x: 0.8087,\n    y: 0.996\n  }, {\n    x: 0.6644,\n    y: 0.9914\n  }, {\n    x: 0.48419999999999996,\n    y: 0.9813\n  }, {\n    x: 0.3077,\n    y: 0.9591\n  }, {\n    x: 0.17179999999999995,\n    y: 0.9134\n  }, {\n    x: 0.08660000000000001,\n    y: 0.8282\n  }, {\n    x: 0.04090000000000005,\n    y: 0.6923\n  }, {\n    x: 0.01870000000000005,\n    y: 0.5158\n  }, {\n    x: 0.008600000000000052,\n    y: 0.3356\n  }, {\n    x: 0.0040000000000000036,\n    y: 0.19130000000000003\n  }, {\n    x: 0.0019000000000000128,\n    y: 0.09789999999999999\n  }, {\n    x: 0.0009000000000000119,\n    y: 0.046599999999999975\n  }, {\n    x: 0.0004999999999999449,\n    y: 0.021399999999999975\n  }, {\n    x: 0.00019999999999997797,\n    y: 0.009800000000000031\n  }, {\n    x: 0.00009999999999998899,\n    y: 0.0044999999999999485\n  }, {\n    x: 0.00009999999999998899,\n    y: 0.0020999999999999908\n  }, {\n    x: 0,\n    y: 0.0010000000000000009\n  }, {\n    x: 0,\n    y: 0.0004999999999999449\n  }],\n  t_value: -2.2502,\n  p_value: 0.0255,\n  getROCChart(roc_curve, t_value, p_value) {\n    return new chart_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](elem(\"roc_curve\"), {\n      type: 'scatter',\n      data: {\n        datasets: [{\n          data: [{\n            x: 0,\n            y: 0\n          }, {\n            x: 1,\n            y: 1\n          }],\n          label: \"refs\",\n          borderColor: \"transparent\",\n          fill: false\n        }, {\n          data: [],\n          label: \"TPR\",\n          borderColor: \"#000000\",\n          backgroundColor: \"#000000\",\n          fill: true,\n          pointRadius: 4\n        }, {\n          data: [{\n            x: 0,\n            y: 0\n          }, {\n            x: 1,\n            y: 1\n          }],\n          // random curve for reference\n          label: \"Random\",\n          borderColor: \"#dedede\",\n          fill: false\n        }, {\n          data: roc_curve,\n          label: \"ROC curve\",\n          borderColor: \"#7600bc\",\n          backgroundColor: \"#ca5cdd\",\n          fill: true\n          // ,pointRadius: 4\n        }]\n      },\n\n      options: {\n        animation: false,\n        title: {\n          display: false,\n          text: 't-test'\n        },\n        legend: {\n          position: 'bottom',\n          labels: {\n            filter: function (item, chart) {\n              return !item.text.includes('refs'); // Remove the refs legend item\n            },\n\n            usePointStyle: true\n          }\n        },\n        elements: {\n          point: {\n            radius: 0\n          }\n        },\n        scales: {\n          xAxes: [{\n            ticks: {\n              min: 0,\n              stepSize: 0.2,\n              // stepValue: 0.2,\n              steps: 10,\n              max: 1\n            },\n            display: true,\n            gridLines: {\n              display: false\n            },\n            scaleLabel: {\n              display: true,\n              labelString: 'False positive rate (\\u03B1)'\n            }\n          }],\n          yAxes: [{\n            ticks: {\n              min: 0,\n              stepSize: 0.2,\n              max: 1\n            },\n            display: true,\n            scaleLabel: {\n              display: true,\n              labelString: 'True positive rate (1 - \\u03B2)'\n            },\n            gridLines: {\n              display: false\n            }\n          }]\n        },\n        annotation: {\n          annotations: [{\n            type: 'line',\n            mode: 'vertical',\n            scaleID: 'x-axis-1',\n            value: t_value,\n            borderColor: '#c8c8c8',\n            borderWidth: 2,\n            borderDash: [10, 5],\n            label: {\n              enabled: true,\n              content: 'p = ',\n              backgroundColor: 'transparent',\n              fontColor: '#c8c8c8',\n              position: \"top\"\n            }\n          }, {\n            type: 'line',\n            mode: 'vertical',\n            scaleID: 'x-axis-1',\n            value: p_value,\n            borderColor: '#ff7034',\n            borderWidth: 2,\n            label: {\n              enabled: true,\n              content: '',\n              backgroundColor: 'transparent',\n              fontColor: '#4d4e4f',\n              yAdjust: 20,\n              position: \"top\"\n            }\n          }],\n          drawTime: \"afterDatasetsDraw\"\n        }\n      }\n    });\n  }\n\n  // computeArea(x, df) {\n  //     X=eval(x)\n  //     df=eval(df)\n  //     with (Math) {\n  //     if (df<=0) {\n  //       alert(\"Degrees of freedom must be positive\")\n  //     } else {\n  //       A=df/2;\n  //       S=A+.5;\n  //       Z=df/(df+X*X);\n  //       BT=exp(LogGamma(S)-LogGamma(.5)-LogGamma(A)+A*log(Z)+.5*log(1-Z));\n  //       if (Z<(A+1)/(S+2)) {\n  //         betacdf=BT*Betinc(Z,A,.5)\n  //       } else {\n  //         betacdf=1-BT*Betinc(1-Z,.5,A)\n  //       }\n  //       if (X<0) {\n  //         tcdf=betacdf/2\n  //       } else {\n  //         tcdf=1-betacdf/2\n  //       }\n  //     }\n  //     // tcdf=round(tcdf*100000)/100000;\n  //     // tcdf=tcdf*100000/100000;\n  //   }\n  //     return round(tcdf);\n  // },\n\n  // LogGamma(Z) {\n  //   with (Math) {\n  //     var S=1+76.18009173/Z-86.50532033/(Z+1)+24.01409822/(Z+2)-1.231739516/(Z+3)+.00120858003/(Z+4)-.00000536382/(Z+5);\n  //     var LG= (Z-.5)*log(Z+4.5)-(Z+4.5)+log(S*2.50662827465);\n  //   }\n  //   return LG\n  // },\n\n  // Betinc(X,A,B) {\n  //   var A0=0;\n  //   var B0=1;\n  //   var A1=1;\n  //   var B1=1;\n  //   var M9=0;\n  //   var A2=0;\n  //   var C9;\n  //   while (Math.abs((A1-A2)/A1)>.00001) {\n  //     A2=A1;\n  //     C9=-(A+M9)*(A+B+M9)*X/(A+2*M9)/(A+2*M9+1);\n  //     A0=A1+C9*A0;\n  //     B0=B1+C9*B0;\n  //     M9=M9+1;\n  //     C9=M9*(B-M9)*X/(A+2*M9-1)/(A+2*M9);\n  //     A1=A0+C9*A1;\n  //     B1=B0+C9*B1;\n  //     A0=A0/B1;\n  //     B0=B0/B1;\n  //     A1=A1/B1;\n  //     B1=1;\n  //   }\n  //   return A1/A\n  // },\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (welchs);\n\n// function getFalseDiscoveryRate(FP, TP){\n//   /*Calculate the False Discovery Rate (FDR)\n//   FP: False Positive\n//   TP: True Positive\n//   */\n//   return math.round(100*FP/(FP + TP),2);\n// }\n\n// function computeArea(x, df) {\n//     X=eval(x)\n//     df=eval(df)\n//     with (Math) {\n// \t\tif (df<=0) {\n// \t\t\talert(\"Degrees of freedom must be positive\")\n// \t\t} else {\n// \t\t\tA=df/2;\n// \t\t\tS=A+.5;\n// \t\t\tZ=df/(df+X*X);\n// \t\t\tBT=exp(LogGamma(S)-LogGamma(.5)-LogGamma(A)+A*log(Z)+.5*log(1-Z));\n// \t\t\tif (Z<(A+1)/(S+2)) {\n// \t\t\t\tbetacdf=BT*Betinc(Z,A,.5)\n// \t\t\t} else {\n// \t\t\t\tbetacdf=1-BT*Betinc(1-Z,.5,A)\n// \t\t\t}\n// \t\t\tif (X<0) {\n// \t\t\t\ttcdf=betacdf/2\n// \t\t\t} else {\n// \t\t\t\ttcdf=1-betacdf/2\n// \t\t\t}\n// \t\t}\n// \t\t// tcdf=round(tcdf*100000)/100000;\n// \t\t// tcdf=tcdf*100000/100000;\n// \t}\n//     return round(tcdf);\n// }\n\n// function LogGamma(Z) {\n// \twith (Math) {\n// \t\tvar S=1+76.18009173/Z-86.50532033/(Z+1)+24.01409822/(Z+2)-1.231739516/(Z+3)+.00120858003/(Z+4)-.00000536382/(Z+5);\n// \t\tvar LG= (Z-.5)*log(Z+4.5)-(Z+4.5)+log(S*2.50662827465);\n// \t}\n// \treturn LG\n// }\n\n// function Betinc(X,A,B) {\n// \tvar A0=0;\n// \tvar B0=1;\n// \tvar A1=1;\n// \tvar B1=1;\n// \tvar M9=0;\n// \tvar A2=0;\n// \tvar C9;\n// \twhile (Math.abs((A1-A2)/A1)>.00001) {\n// \t\tA2=A1;\n// \t\tC9=-(A+M9)*(A+B+M9)*X/(A+2*M9)/(A+2*M9+1);\n// \t\tA0=A1+C9*A0;\n// \t\tB0=B1+C9*B0;\n// \t\tM9=M9+1;\n// \t\tC9=M9*(B-M9)*X/(A+2*M9-1)/(A+2*M9);\n// \t\tA1=A0+C9*A1;\n// \t\tB1=B0+C9*B1;\n// \t\tA0=A0/B1;\n// \t\tB0=B0/B1;\n// \t\tA1=A1/B1;\n// \t\tB1=1;\n// \t}\n// \treturn A1/A\n// }\n\n// function getLineChart(axes, group1, group2, p_value, crit_t_value){\n//   return new Chart(elem(\"line_chart\"), {\n//       type: 'scatter',\n//       data: {\n//         datasets: [{\n//             data: [\n//               {x: axes.x_min, y: 0},\n//               {x: axes.x_max, y: 0},\n//             ],\n//             label: \"refs\",\n//             borderColor: \"transparent\",\n//             fill: false\n//           },{\n//             data: group1.dist,\n//             label: \"Group 1\",\n//             borderColor: \"#ff0000\",\n//             fill: false\n//           }, {\n//             data: group2.dist,\n//             label: \"Group 2\",\n//             borderColor: \"#0000ff\",\n//             fill: false,\n//           }, {\n//             data: [], // Alpha Curve\n//             label: \"\\u03B1\",\n//             borderColor: \"transparent\",\n//             backgroundColor: \"#ff000055\",\n//             fill: true\n//           }, {\n//             data: [], // Beta Curve\n//             label: \"\\u03B2\",\n//             borderColor: \"transparent\",\n//             backgroundColor: \"#0000ff55\",\n//             fill: true\n//           }\n//         ]\n//       },\n//       options: {\n//         animation: false,\n//         title: {\n//           display: false,\n//           text: 't-test'\n//         },\n//         legend:{\n//           position: 'bottom',\n//           labels: {\n//             filter: function(item, chart) {\n//                 return !item.text.includes('refs'); // Remove the refs legend item\n//               },\n//              usePointStyle: true,\n//            },\n//         },\n//         elements: {\n//           point:{\n//               radius: 0\n//           }\n//         },\n//         scales: {\n//           xAxes: [{\n//               ticks : {\n//               min: axes.x_min,\n//               stepSize: axes.step_size,\n//                   max: axes.x_max,\n//               },\n//             display: true,\n//             gridLines: {\n//               display:false,\n//             },\n//             scaleLabel: {\n//               display: true,\n//               labelString: 't'\n//             }\n//           }],\n//           yAxes: [{\n//             ticks : {\n//               min: 0,\n//               max: axes.y_max,\n//             },\n//             display: true,\n//             scaleLabel: {\n//               display: true,\n//               labelString: 'Normalized Frequency'\n//             },\n//             gridLines: {\n//                 display:false\n//             }\n//           }]\n//         },\n//         annotation: {\n//           annotations: [{\n//             type: 'line',\n//             mode: 'vertical',\n//             scaleID: 'x-axis-1',\n//             value: t_value,\n//             borderColor: '#c8c8c8',\n//             borderWidth: 2,\n//             borderDash: [10,5],\n//             label: {\n//               enabled: true,\n//               content: 'p = ' + p_value,\n//               backgroundColor: 'transparent',\n//               fontColor: '#c8c8c8',\n//               position: \"top\",\n//             }\n//           },{\n//             type: 'line',\n//             mode: 'vertical',\n//             scaleID: 'x-axis-1',\n//             value: crit_t_value,\n//             borderColor: '#ff7034',\n//             borderWidth: 2,\n//             label: {\n//               enabled: true,\n//               content: '\\u03B1',\n//               backgroundColor: 'transparent',\n//               fontColor: '#4d4e4f',\n//               yAdjust: 20,\n//               position: \"top\",\n//             }\n//           }\n//           ],\n//           drawTime: \"afterDatasetsDraw\" \n//         }\n//       }\n//     });\n// }\n\n// function getROCChart(roc_curve){\n//   return new Chart(elem(\"roc_curve\"), {\n//       type: 'scatter',\n//       data: {\n//         datasets: [{\n//             data: [\n//               {x: 0, y: 0},\n//               {x: 1, y: 1},\n//             ],\n//             label: \"refs\",\n//             borderColor: \"transparent\",\n//             fill: false\n//           },{\n//             data: [], \n//             label: \"TPR\",\n//             borderColor: \"#000000\",\n//             backgroundColor: \"#000000\",\n//             fill: true,\n//             pointRadius: 4\n//           }, {\n//             data: [{x:0,y:0}, {x:1,y:1}], // random curve for reference\n//             label: \"Random\",\n//             borderColor: \"#dedede\",\n//             fill: false\n//           },{\n//             data: roc_curve,\n//             label: \"ROC curve\",\n//             borderColor: \"#7600bc\",\n//             backgroundColor: \"#ca5cdd\",\n//             fill: true\n//             // ,pointRadius: 4\n//           }\n//         ]\n//       },\n//       options: {\n//         animation: false,\n//         title: {\n//           display: false,\n//           text: 't-test'\n//         },\n//         legend:{\n//           position: 'bottom',\n//           labels: {\n//             filter: function(item, chart) {\n//                 return !item.text.includes('refs'); // Remove the refs legend item\n//               },\n//              usePointStyle: true,\n//            },\n//         },\n//         elements: {\n//           point:{\n//               radius: 0\n//           }\n//         },\n//         scales: {\n//           xAxes: [{\n//               ticks : {\n//                 min: 0,\n//                 stepSize: 0.2,\n//                 // stepValue: 0.2,\n//                 steps: 10,\n//                 max: 1,\n//               },\n//             display: true,\n//             gridLines: {\n//               display:false,\n//             },\n//             scaleLabel: {\n//               display: true,\n//               labelString: 'False positive rate (\\u03B1)'\n//             }\n//           }],\n//           yAxes: [{\n//             ticks : {\n//               min: 0,\n//               stepSize: 0.2,\n//               max: 1,\n//             },\n//             display: true,\n//             scaleLabel: {\n//               display: true,\n//               labelString: 'True positive rate (1 - \\u03B2)'\n//             },\n//             gridLines: {\n//                 display:false\n//             }\n//           }]\n//         },\n//         annotation: {\n//           annotations: [{\n//             type: 'line',\n//             mode: 'vertical',\n//             scaleID: 'x-axis-1',\n//             value: t_value,\n//             borderColor: '#c8c8c8',\n//             borderWidth: 2,\n//             borderDash: [10,5],\n//             label: {\n//               enabled: true,\n//               content: 'p = ',\n//               backgroundColor: 'transparent',\n//               fontColor: '#c8c8c8',\n//               position: \"top\",\n//             }\n//           },{\n//             type: 'line',\n//             mode: 'vertical',\n//             scaleID: 'x-axis-1',\n//             value: p_value,\n//             borderColor: '#ff7034',\n//             borderWidth: 2,\n//             label: {\n//               enabled: true,\n//               content: '',\n//               backgroundColor: 'transparent',\n//               fontColor: '#4d4e4f',\n//               yAdjust: 20,\n//               position: \"top\",\n//             }\n//           }\n//           ],\n//           drawTime: \"afterDatasetsDraw\" \n//         }\n//       }\n//     });\n// }\n\n//     /*\n//     Functions below may be used at a future date.\n\n//     BELOW FOR NORMAL CURVE (Z-TEST)\n//     function error_f(x, mean, sd){\n//       return (1/(sd*math.sqrt(2*math.pi)))*math.exp((-((x-mean) ** 2))/(2*sd ** 2));\n//     }\n\n//     function area_under_curve(x1, x2, mean, sd){\n//       return -0.5*(math.erf((mean-x2)/(math.sqrt(2)*sd)) - math.erf((mean-x1)/(math.sqrt(2)*sd)));\n//     }\n\n//     const width  = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;\n//     if (width <= 1000){\n//       lineChart.options.annotation.annotations[0].label['enabled'] = true;\n//       lineChart.options.annotation.annotations[1].label['enabled'] = true;\n//       lineChart.update();\n//     }\n//     */\n\n//     /*\n//     Bayes Factor = Likelihood Ratio = Sensitivity / False Positive Rate\n//     *///# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvd2VsY2hzLmpzLmpzIiwibWFwcGluZ3MiOiI7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUdBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBR0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFHQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFNQTs7QUFHQTs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBR0E7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBR0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlYXBwLy4vc3JjL3dlbGNocy5qcz9kZjllIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGZ1bmN0aW9uIGRyYXdBbHBoYUN1cnZlKGdyb3VwMSwgY3JpdF90X3ZhbHVlKXtcclxuLy8gICAgIC8vIEZpbGwgdGhlIGFyZWEgdW5kZXIgdGhlIGN1cnZlIHJlcHJlc2VudGluZyBhbHBoYS5cclxuLy8gICAgIGxldCBhbHBoYV9jdXJ2ZSA9IFtdO1xyXG4vLyAgICAgLy8gdGhpcyBkYXRhcG9pbnQgY29ubmVjdHMgd2l0aCB0aGUgY3JpdGljYWwgdCB2ZXJ0aWNhbCBsaW5lXHJcbi8vICAgICBhbHBoYV9jdXJ2ZS5wdXNoKHt4OiBjcml0X3RfdmFsdWUsIHk6IHRfRGlzdHJpYihjcml0X3RfdmFsdWUsIGdyb3VwMS5kZil9KTtcclxuLy8gICAgIGZvcih2YXIgaSA9IDA7IGkgPCBncm91cDEuZGlzdC5sZW5ndGg7IGkrKykge1xyXG4vLyAgICAgICBpZiAoZ3JvdXAxLmRpc3RbaV1bJ3gnXSA+IGNyaXRfdF92YWx1ZSl7XHJcbi8vICAgICAgICAgYWxwaGFfY3VydmUucHVzaCh7eDogZ3JvdXAxLmRpc3RbaV1bJ3gnXSwgeTogZ3JvdXAxLmRpc3RbaV1bJ3knXX0pO1xyXG4vLyAgICAgICB9XHJcbi8vICAgICB9XHJcbi8vICAgICBsaW5lQ2hhcnQuZGF0YS5kYXRhc2V0c1szXVsnZGF0YSddID0gYWxwaGFfY3VydmU7XHJcbi8vICAgICBsaW5lQ2hhcnQudXBkYXRlKCk7XHJcbi8vICAgfVxyXG4gIFxyXG4gIFxyXG4vLyAgIGZ1bmN0aW9uIGRyYXdCZXRhQ3VydmUoZ3JvdXAyLCBjcml0X3RfdmFsdWUpe1xyXG4vLyAgICAgLy8gRmlsbCB0aGUgYXJlYSB1bmRlciB0aGUgY3VydmUgcmVwcmVzZW50aW5nIGJldGEuXHJcbi8vICAgICBsZXQgYmV0YV9jdXJ2ZSA9IFtdO1xyXG4vLyAgICAgZm9yKHZhciBpID0gMDsgaSA8IGdyb3VwMi5kaXN0Lmxlbmd0aDsgaSsrKSB7XHJcbi8vICAgICAgIGlmIChncm91cDIuZGlzdFtpXVsneCddIDwgY3JpdF90X3ZhbHVlKXtcclxuLy8gICAgICAgICBiZXRhX2N1cnZlLnB1c2goe3g6IGdyb3VwMi5kaXN0W2ldWyd4J10sIHk6IGdyb3VwMi5kaXN0W2ldWyd5J119KTtcclxuLy8gICAgICAgfVxyXG4vLyAgICAgfVxyXG4vLyAgICAgLy8gdGhpcyBkYXRhcG9pbnQgY29ubmVjdHMgd2l0aCB0aGUgY3JpdGljYWwgdCB2ZXJ0aWNhbCBsaW5lXHJcbi8vICAgICBiZXRhX2N1cnZlLnB1c2goe3g6IGNyaXRfdF92YWx1ZSwgeTogdF9EaXN0cmliKGNyaXRfdF92YWx1ZS1uY3AsIGdyb3VwMi5kZil9KTsgLy8gbmNwIGFjdHMgYXMgb2Zmc2V0XHJcbi8vICAgICBsaW5lQ2hhcnQuZGF0YS5kYXRhc2V0c1s0XVsnZGF0YSddID0gYmV0YV9jdXJ2ZTtcclxuLy8gICAgIGxpbmVDaGFydC51cGRhdGUoKTtcclxuLy8gICB9XHJcbiAgXHJcblxyXG5cclxuXHJcbi8vIGZ1bmN0aW9uIHRfRGlzdHJpYih0LCBkb2Ype1xyXG4vLyAgIC8vIEZvciBhIGdpdmVuIHgsIHJldHVybiB0aGUgdCBkaXN0cmlidXRpb24geSB2YWx1ZS5cclxuLy8gICB5ID0gKG1hdGguZ2FtbWEoKGRvZisxKS8yKS8obWF0aC5zcXJ0KGRvZiptYXRoLnBpKSptYXRoLmdhbW1hKGRvZi8yKSkpICogKDErKCh0KioyKS9kb2YpKSoqKC0oZG9mKzEpLzIpO1xyXG4vLyAgIHJldHVybiBtYXRoLnJvdW5kKHksIDYpO1xyXG4vLyB9XHJcblxyXG5cclxuLy8gZnVuY3Rpb24gZ2V0QWxwaGEoY3JpdF90X3ZhbHVlLCBkZil7XHJcbi8vICAgcmV0dXJuIDEgLSBjb21wdXRlQXJlYShjcml0X3RfdmFsdWUsIGRmKTtcclxuLy8gfVxyXG5cclxuLy8gZnVuY3Rpb24gZ2V0QmV0YShjcml0X3RfdmFsdWVfYmV0YSwgZGYpe1xyXG4vLyAgIHJldHVybiBjb21wdXRlQXJlYShjcml0X3RfdmFsdWVfYmV0YSwgZGYpO1xyXG4vLyB9XHJcblxyXG5cclxuLy8gZnVuY3Rpb24gZ2V0Um9jQ3VydmUoYXhlcyl7XHJcbi8vICAgY29uc29sZS5sb2coXCJheGVzLnhfbWF4XCIsIGF4ZXMueF9tYXgpO1xyXG4vLyAgIGNvbnNvbGUubG9nKFwiYXhlcy54X21pbjpcIiwgYXhlcy54X21pbik7XHJcbi8vICAgbGV0IHBhcnRpdGlvbnMgPSAyNTtcclxuLy8gICBzdGVwX3NpemUgPSAoYXhlcy54X21heCAtIGF4ZXMueF9taW4pL3BhcnRpdGlvbnM7XHJcbi8vICAgY29uc29sZS5sb2coXCJzdGVwX3NpemU6XCIsIHN0ZXBfc2l6ZSk7XHJcbi8vICAgY29uc29sZS5sb2coKTtcclxuLy8gICByb2NfY3VydmU9W107XHJcbi8vICAgLy8gY3JpdF90X3ZhbHVlX2JldGEgPSBjcml0X3RfdmFsdWUgLSBuY3A7XHJcbi8vICAgZm9yKHZhciBpID0gMDsgaSA8PSBwYXJ0aXRpb25zOyBpKyspIHtcclxuLy8gICAgIHJvY19jdXJ2ZS5wdXNoKHt4OiBnZXRBbHBoYSgoYXhlcy54X21pbisoaSpzdGVwX3NpemUpKSwgZGYpLCB5OiAxLWdldEJldGEoKChheGVzLnhfbWluKyhpKnN0ZXBfc2l6ZSkpKS1uY3AsIGRmKX0pOyAgICBcclxuLy8gICB9XHJcbi8vICAgY29uc29sZS5sb2coXCJyb2NfY3VydmU6XCIsIHJvY19jdXJ2ZSk7XHJcbi8vICAgcmV0dXJuIHJvY19jdXJ2ZTtcclxuLy8gfVxyXG5cclxuXHJcbi8vIGZ1bmN0aW9uIGdldEFVQyhheGVzKXtcclxuLy8gICAvLyBjYWxjdWxhdGUgQVVDIHVzaW5nIHRoZSBsZWZ0IFJpZW1hbm4gU3VtXHJcbi8vICAgY29uc29sZS5sb2coXCJheGVzLnhfbWF4XCIsIGF4ZXMueF9tYXgpO1xyXG4vLyAgIGNvbnNvbGUubG9nKFwiYXhlcy54X21pbjpcIiwgYXhlcy54X21pbik7XHJcbi8vICAgbGV0IHBhcnRpdGlvbnMgPSA1MDA7XHJcbi8vICAgbGV0IHN0ZXBfc2l6ZSA9IChheGVzLnhfbWF4IC0gYXhlcy54X21pbikvcGFydGl0aW9ucztcclxuLy8gICBjb25zb2xlLmxvZyhcInN0ZXBfc2l6ZTpcIiwgc3RlcF9zaXplKTtcclxuLy8gICBjb25zb2xlLmxvZygpO1xyXG4vLyAgIGxldCByb2NfY3VydmU9W107XHJcbi8vICAgbGV0IGF1YyA9IDA7XHJcbi8vICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gcGFydGl0aW9uczsgaSsrKSB7XHJcbi8vICAgICByb2NfY3VydmUucHVzaCh7eDogZ2V0QWxwaGEoKGF4ZXMueF9taW4rKGkqc3RlcF9zaXplKSksIGRmKSwgeTogMS1nZXRCZXRhKCgoYXhlcy54X21pbisoaSpzdGVwX3NpemUpKSktbmNwLCBkZil9KTsgICAgXHJcbi8vICAgfVxyXG4vLyAgIC8vIGNhbGN1bGF0ZSBsZWZ0IFJpZW1hbm4gU3VtXHJcbi8vICAgZm9yICh2YXIgaSA9IDA7IGkgPCByb2NfY3VydmUubGVuZ3RoLTE7IGkrKykge1xyXG4vLyAgICAgYXVjID0gYXVjICsgKHJvY19jdXJ2ZVtpXS54LXJvY19jdXJ2ZVtpKzFdLngpKnJvY19jdXJ2ZVtpXS55O1xyXG4vLyAgIH1cclxuXHJcbi8vICAgY29uc29sZS5sb2coXCJhdWM6XCIsIGF1Yyk7XHJcbi8vICAgcmV0dXJuIG1hdGgucm91bmQoYXVjLCAyKTtcclxuLy8gfVxyXG5cclxuaW1wb3J0ICogYXMgbWF0aCBmcm9tICdtYXRoanMnO1xyXG5pbXBvcnQgQ2hhcnQgZnJvbSBcImNoYXJ0LmpzXCI7XHJcblxyXG5cclxudmFyIHdlbGNocyA9IHtcclxuXHJcbiAgLy8gcHJvdmlkZXMgc2hvcnRoYW5kIGZvciBnZXR0aW5nIGVsZW1lbnQgaWRcclxuICBlbGVtKGVsZW1faWQpe1xyXG4gICAgcmV0dXJuIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGVsZW1faWQpO1xyXG4gIH0sXHJcblxyXG5cclxuICBnZXRGYWxzZURpc2NvdmVyeVJhdGUoRlAsIFRQKSB7XHJcbiAgICBjb25zb2xlLmxvZyhcIkZEUiBpbnB1dCBGUDpcIiwgRlApO1xyXG4gICAgY29uc29sZS5sb2coXCJGRFIgaW5wdXQgVFA6XCIsIFRQKTtcclxuICAgIHJldHVybiBtYXRoLnJvdW5kKDEwMCpOdW1iZXIoRlApLyhOdW1iZXIoRlApICsgTnVtYmVyKFRQKSksMik7XHJcbiAgfSxcclxuXHJcblxyXG4gIC8vIGdldEFscGhhKGNyaXRfdF92YWx1ZSwgZGYpe1xyXG4gIC8vICAgcmV0dXJuIDEgLSBjb21wdXRlQXJlYShjcml0X3RfdmFsdWUsIGRmKTtcclxuICAvLyB9LFxyXG5cclxuICAvLyBnZXRCZXRhKGNyaXRfdF92YWx1ZV9iZXRhLCBkZil7XHJcbiAgLy8gICByZXR1cm4gY29tcHV0ZUFyZWEoY3JpdF90X3ZhbHVlX2JldGEsIGRmKTtcclxuICAvLyB9LFxyXG5cclxuXHJcbiAgLy8gZ2V0Um9jQ3VydmUoYXhlcywgZGYsIG5jcCl7XHJcbiAgLy8gICBjb25zb2xlLmxvZyhcImF4ZXMueF9tYXhcIiwgYXhlcy54X21heCk7XHJcbiAgLy8gICBjb25zb2xlLmxvZyhcImF4ZXMueF9taW46XCIsIGF4ZXMueF9taW4pO1xyXG4gIC8vICAgbGV0IHBhcnRpdGlvbnMgPSAyNTtcclxuICAvLyAgIHN0ZXBfc2l6ZSA9IChheGVzLnhfbWF4IC0gYXhlcy54X21pbikvcGFydGl0aW9ucztcclxuICAvLyAgIGNvbnNvbGUubG9nKFwic3RlcF9zaXplOlwiLCBzdGVwX3NpemUpO1xyXG4gIC8vICAgY29uc29sZS5sb2coKTtcclxuICAvLyAgIHJvY19jdXJ2ZT1bXTtcclxuICAvLyAgIC8vIGNyaXRfdF92YWx1ZV9iZXRhID0gY3JpdF90X3ZhbHVlIC0gbmNwO1xyXG4gIC8vICAgZm9yKHZhciBpID0gMDsgaSA8PSBwYXJ0aXRpb25zOyBpKyspIHtcclxuICAvLyAgICAgcm9jX2N1cnZlLnB1c2goe3g6IGdldEFscGhhKChheGVzLnhfbWluKyhpKnN0ZXBfc2l6ZSkpLCBkZiksIHk6IDEtZ2V0QmV0YSgoKGF4ZXMueF9taW4rKGkqc3RlcF9zaXplKSkpLW5jcCwgZGYpfSk7ICAgIFxyXG4gIC8vICAgfVxyXG4gIC8vICAgY29uc29sZS5sb2coXCJyb2NfY3VydmU6XCIsIHJvY19jdXJ2ZSk7XHJcbiAgLy8gICByZXR1cm4gcm9jX2N1cnZlO1xyXG4gIC8vIH0sXHJcblxyXG4gIFxyXG4gIHJvY19jdXJ2ZTogXHJcbiAgICBbe3g6MC45OTk1LCB5OiAxfSwgXHJcbiAgICB7eDowLjk5OSwgeTogMX0sIFxyXG4gICAge3g6MC45OTc5LCB5OiAwLjk5OTl9LCBcclxuICAgIHt4OjAuOTk1NSwgeTogMC45OTk5fSwgXHJcbiAgICB7eDowLjk5MDIsIHk6IDAuOTk5OH0sIFxyXG4gICAge3g6MC45Nzg2LCB5OiAwLjk5OTV9LCBcclxuICAgIHt4OjAuOTUzNCwgeTogMC45OTkxfSwgXHJcbiAgICB7eDowLjkwMjEsIHk6IDAuOTk4MX0sIFxyXG4gICAge3g6MC44MDg3LCB5OiAwLjk5Nn0sIFxyXG4gICAge3g6MC42NjQ0LCB5OiAwLjk5MTR9LCBcclxuICAgIHt4OjAuNDg0MTk5OTk5OTk5OTk5OTYsIHk6IDAuOTgxM30sIFxyXG4gICAge3g6MC4zMDc3LCB5OiAwLjk1OTF9LCBcclxuICAgIHt4OjAuMTcxNzk5OTk5OTk5OTk5OTUsIHk6IDAuOTEzNH0sIFxyXG4gICAge3g6MC4wODY2MDAwMDAwMDAwMDAwMSwgeTogMC44MjgyfSwgXHJcbiAgICB7eDowLjA0MDkwMDAwMDAwMDAwMDA1LCB5OiAwLjY5MjN9LCBcclxuICAgIHt4OjAuMDE4NzAwMDAwMDAwMDAwMDUsIHk6IDAuNTE1OH0sIFxyXG4gICAge3g6MC4wMDg2MDAwMDAwMDAwMDAwNTIsIHk6IDAuMzM1Nn0sIFxyXG4gICAge3g6MC4wMDQwMDAwMDAwMDAwMDAwMDM2LCB5OiAwLjE5MTMwMDAwMDAwMDAwMDAzfSwgXHJcbiAgICB7eDowLjAwMTkwMDAwMDAwMDAwMDAxMjgsIHk6IDAuMDk3ODk5OTk5OTk5OTk5OTl9LCBcclxuICAgIHt4OjAuMDAwOTAwMDAwMDAwMDAwMDExOSwgeTogMC4wNDY1OTk5OTk5OTk5OTk5NzV9LCBcclxuICAgIHt4OjAuMDAwNDk5OTk5OTk5OTk5OTQ0OSwgeTogMC4wMjEzOTk5OTk5OTk5OTk5NzV9LCBcclxuICAgIHt4OjAuMDAwMTk5OTk5OTk5OTk5OTc3OTcsIHk6IDAuMDA5ODAwMDAwMDAwMDAwMDMxfSwgXHJcbiAgICB7eDowLjAwMDA5OTk5OTk5OTk5OTk4ODk5LCB5OiAwLjAwNDQ5OTk5OTk5OTk5OTk0ODV9LCBcclxuICAgIHt4OjAuMDAwMDk5OTk5OTk5OTk5OTg4OTksIHk6IDAuMDAyMDk5OTk5OTk5OTk5OTkwOH0sIFxyXG4gICAge3g6MCwgeTogMC4wMDEwMDAwMDAwMDAwMDAwMDA5fSwgXHJcbiAgICB7eDowLCB5OiAwLjAwMDQ5OTk5OTk5OTk5OTk0NDl9XSxcclxuXHJcblxyXG4gICAgdF92YWx1ZTogLTIuMjUwMixcclxuICAgIHBfdmFsdWU6IDAuMDI1NSxcclxuXHJcbiAgZ2V0Uk9DQ2hhcnQocm9jX2N1cnZlLCB0X3ZhbHVlLCBwX3ZhbHVlKXtcclxuICByZXR1cm4gbmV3IENoYXJ0KGVsZW0oXCJyb2NfY3VydmVcIiksIHtcclxuICAgICAgdHlwZTogJ3NjYXR0ZXInLFxyXG4gICAgICBkYXRhOiB7XHJcbiAgICAgICAgZGF0YXNldHM6IFt7XHJcbiAgICAgICAgICAgIGRhdGE6IFtcclxuICAgICAgICAgICAgICB7eDogMCwgeTogMH0sXHJcbiAgICAgICAgICAgICAge3g6IDEsIHk6IDF9LFxyXG4gICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICBsYWJlbDogXCJyZWZzXCIsXHJcbiAgICAgICAgICAgIGJvcmRlckNvbG9yOiBcInRyYW5zcGFyZW50XCIsXHJcbiAgICAgICAgICAgIGZpbGw6IGZhbHNlXHJcbiAgICAgICAgICB9LHtcclxuICAgICAgICAgICAgZGF0YTogW10sIFxyXG4gICAgICAgICAgICBsYWJlbDogXCJUUFJcIixcclxuICAgICAgICAgICAgYm9yZGVyQ29sb3I6IFwiIzAwMDAwMFwiLFxyXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiIzAwMDAwMFwiLFxyXG4gICAgICAgICAgICBmaWxsOiB0cnVlLFxyXG4gICAgICAgICAgICBwb2ludFJhZGl1czogNFxyXG4gICAgICAgICAgfSwge1xyXG4gICAgICAgICAgICBkYXRhOiBbe3g6MCx5OjB9LCB7eDoxLHk6MX1dLCAvLyByYW5kb20gY3VydmUgZm9yIHJlZmVyZW5jZVxyXG4gICAgICAgICAgICBsYWJlbDogXCJSYW5kb21cIixcclxuICAgICAgICAgICAgYm9yZGVyQ29sb3I6IFwiI2RlZGVkZVwiLFxyXG4gICAgICAgICAgICBmaWxsOiBmYWxzZVxyXG4gICAgICAgICAgfSx7XHJcbiAgICAgICAgICAgIGRhdGE6IHJvY19jdXJ2ZSxcclxuICAgICAgICAgICAgbGFiZWw6IFwiUk9DIGN1cnZlXCIsXHJcbiAgICAgICAgICAgIGJvcmRlckNvbG9yOiBcIiM3NjAwYmNcIixcclxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIiNjYTVjZGRcIixcclxuICAgICAgICAgICAgZmlsbDogdHJ1ZVxyXG4gICAgICAgICAgICAvLyAscG9pbnRSYWRpdXM6IDRcclxuICAgICAgICAgIH1cclxuICAgICAgICBdXHJcbiAgICAgIH0sXHJcbiAgICAgIG9wdGlvbnM6IHtcclxuICAgICAgICBhbmltYXRpb246IGZhbHNlLFxyXG4gICAgICAgIHRpdGxlOiB7XHJcbiAgICAgICAgICBkaXNwbGF5OiBmYWxzZSxcclxuICAgICAgICAgIHRleHQ6ICd0LXRlc3QnXHJcbiAgICAgICAgfSxcclxuICAgICAgICBsZWdlbmQ6e1xyXG4gICAgICAgICAgcG9zaXRpb246ICdib3R0b20nLFxyXG4gICAgICAgICAgbGFiZWxzOiB7XHJcbiAgICAgICAgICAgIGZpbHRlcjogZnVuY3Rpb24oaXRlbSwgY2hhcnQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAhaXRlbS50ZXh0LmluY2x1ZGVzKCdyZWZzJyk7IC8vIFJlbW92ZSB0aGUgcmVmcyBsZWdlbmQgaXRlbVxyXG4gICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICB1c2VQb2ludFN0eWxlOiB0cnVlLFxyXG4gICAgICAgICAgIH0sXHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbGVtZW50czoge1xyXG4gICAgICAgICAgcG9pbnQ6e1xyXG4gICAgICAgICAgICAgIHJhZGl1czogMFxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2NhbGVzOiB7XHJcbiAgICAgICAgICB4QXhlczogW3tcclxuICAgICAgICAgICAgICB0aWNrcyA6IHtcclxuICAgICAgICAgICAgICAgIG1pbjogMCxcclxuICAgICAgICAgICAgICAgIHN0ZXBTaXplOiAwLjIsXHJcbiAgICAgICAgICAgICAgICAvLyBzdGVwVmFsdWU6IDAuMixcclxuICAgICAgICAgICAgICAgIHN0ZXBzOiAxMCxcclxuICAgICAgICAgICAgICAgIG1heDogMSxcclxuICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBkaXNwbGF5OiB0cnVlLFxyXG4gICAgICAgICAgICBncmlkTGluZXM6IHtcclxuICAgICAgICAgICAgICBkaXNwbGF5OmZhbHNlLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzY2FsZUxhYmVsOiB7XHJcbiAgICAgICAgICAgICAgZGlzcGxheTogdHJ1ZSxcclxuICAgICAgICAgICAgICBsYWJlbFN0cmluZzogJ0ZhbHNlIHBvc2l0aXZlIHJhdGUgKFxcdTAzQjEpJ1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XSxcclxuICAgICAgICAgIHlBeGVzOiBbe1xyXG4gICAgICAgICAgICB0aWNrcyA6IHtcclxuICAgICAgICAgICAgICBtaW46IDAsXHJcbiAgICAgICAgICAgICAgc3RlcFNpemU6IDAuMixcclxuICAgICAgICAgICAgICBtYXg6IDEsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGRpc3BsYXk6IHRydWUsXHJcbiAgICAgICAgICAgIHNjYWxlTGFiZWw6IHtcclxuICAgICAgICAgICAgICBkaXNwbGF5OiB0cnVlLFxyXG4gICAgICAgICAgICAgIGxhYmVsU3RyaW5nOiAnVHJ1ZSBwb3NpdGl2ZSByYXRlICgxIC0gXFx1MDNCMiknXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGdyaWRMaW5lczoge1xyXG4gICAgICAgICAgICAgICAgZGlzcGxheTpmYWxzZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYW5ub3RhdGlvbjoge1xyXG4gICAgICAgICAgYW5ub3RhdGlvbnM6IFt7XHJcbiAgICAgICAgICAgIHR5cGU6ICdsaW5lJyxcclxuICAgICAgICAgICAgbW9kZTogJ3ZlcnRpY2FsJyxcclxuICAgICAgICAgICAgc2NhbGVJRDogJ3gtYXhpcy0xJyxcclxuICAgICAgICAgICAgdmFsdWU6IHRfdmFsdWUsXHJcbiAgICAgICAgICAgIGJvcmRlckNvbG9yOiAnI2M4YzhjOCcsXHJcbiAgICAgICAgICAgIGJvcmRlcldpZHRoOiAyLFxyXG4gICAgICAgICAgICBib3JkZXJEYXNoOiBbMTAsNV0sXHJcbiAgICAgICAgICAgIGxhYmVsOiB7XHJcbiAgICAgICAgICAgICAgZW5hYmxlZDogdHJ1ZSxcclxuICAgICAgICAgICAgICBjb250ZW50OiAncCA9ICcsXHJcbiAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAndHJhbnNwYXJlbnQnLFxyXG4gICAgICAgICAgICAgIGZvbnRDb2xvcjogJyNjOGM4YzgnLFxyXG4gICAgICAgICAgICAgIHBvc2l0aW9uOiBcInRvcFwiLFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9LHtcclxuICAgICAgICAgICAgdHlwZTogJ2xpbmUnLFxyXG4gICAgICAgICAgICBtb2RlOiAndmVydGljYWwnLFxyXG4gICAgICAgICAgICBzY2FsZUlEOiAneC1heGlzLTEnLFxyXG4gICAgICAgICAgICB2YWx1ZTogcF92YWx1ZSxcclxuICAgICAgICAgICAgYm9yZGVyQ29sb3I6ICcjZmY3MDM0JyxcclxuICAgICAgICAgICAgYm9yZGVyV2lkdGg6IDIsXHJcbiAgICAgICAgICAgIGxhYmVsOiB7XHJcbiAgICAgICAgICAgICAgZW5hYmxlZDogdHJ1ZSxcclxuICAgICAgICAgICAgICBjb250ZW50OiAnJyxcclxuICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICd0cmFuc3BhcmVudCcsXHJcbiAgICAgICAgICAgICAgZm9udENvbG9yOiAnIzRkNGU0ZicsXHJcbiAgICAgICAgICAgICAgeUFkanVzdDogMjAsXHJcbiAgICAgICAgICAgICAgcG9zaXRpb246IFwidG9wXCIsXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICAgIF0sXHJcbiAgICAgICAgICBkcmF3VGltZTogXCJhZnRlckRhdGFzZXRzRHJhd1wiIFxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfSxcclxuXHJcbiAgICBcclxuICAvLyBjb21wdXRlQXJlYSh4LCBkZikge1xyXG4gIC8vICAgICBYPWV2YWwoeClcclxuICAvLyAgICAgZGY9ZXZhbChkZilcclxuICAvLyAgICAgd2l0aCAoTWF0aCkge1xyXG4gIC8vICAgICBpZiAoZGY8PTApIHtcclxuICAvLyAgICAgICBhbGVydChcIkRlZ3JlZXMgb2YgZnJlZWRvbSBtdXN0IGJlIHBvc2l0aXZlXCIpXHJcbiAgLy8gICAgIH0gZWxzZSB7XHJcbiAgLy8gICAgICAgQT1kZi8yO1xyXG4gIC8vICAgICAgIFM9QSsuNTtcclxuICAvLyAgICAgICBaPWRmLyhkZitYKlgpO1xyXG4gIC8vICAgICAgIEJUPWV4cChMb2dHYW1tYShTKS1Mb2dHYW1tYSguNSktTG9nR2FtbWEoQSkrQSpsb2coWikrLjUqbG9nKDEtWikpO1xyXG4gIC8vICAgICAgIGlmIChaPChBKzEpLyhTKzIpKSB7XHJcbiAgLy8gICAgICAgICBiZXRhY2RmPUJUKkJldGluYyhaLEEsLjUpXHJcbiAgLy8gICAgICAgfSBlbHNlIHtcclxuICAvLyAgICAgICAgIGJldGFjZGY9MS1CVCpCZXRpbmMoMS1aLC41LEEpXHJcbiAgLy8gICAgICAgfVxyXG4gIC8vICAgICAgIGlmIChYPDApIHtcclxuICAvLyAgICAgICAgIHRjZGY9YmV0YWNkZi8yXHJcbiAgLy8gICAgICAgfSBlbHNlIHtcclxuICAvLyAgICAgICAgIHRjZGY9MS1iZXRhY2RmLzJcclxuICAvLyAgICAgICB9XHJcbiAgLy8gICAgIH1cclxuICAvLyAgICAgLy8gdGNkZj1yb3VuZCh0Y2RmKjEwMDAwMCkvMTAwMDAwO1xyXG4gIC8vICAgICAvLyB0Y2RmPXRjZGYqMTAwMDAwLzEwMDAwMDtcclxuICAvLyAgIH1cclxuICAvLyAgICAgcmV0dXJuIHJvdW5kKHRjZGYpO1xyXG4gIC8vIH0sXHJcblxyXG4gIC8vIExvZ0dhbW1hKFopIHtcclxuICAvLyAgIHdpdGggKE1hdGgpIHtcclxuICAvLyAgICAgdmFyIFM9MSs3Ni4xODAwOTE3My9aLTg2LjUwNTMyMDMzLyhaKzEpKzI0LjAxNDA5ODIyLyhaKzIpLTEuMjMxNzM5NTE2LyhaKzMpKy4wMDEyMDg1ODAwMy8oWis0KS0uMDAwMDA1MzYzODIvKForNSk7XHJcbiAgLy8gICAgIHZhciBMRz0gKFotLjUpKmxvZyhaKzQuNSktKForNC41KStsb2coUyoyLjUwNjYyODI3NDY1KTtcclxuICAvLyAgIH1cclxuICAvLyAgIHJldHVybiBMR1xyXG4gIC8vIH0sXHJcblxyXG4gIC8vIEJldGluYyhYLEEsQikge1xyXG4gIC8vICAgdmFyIEEwPTA7XHJcbiAgLy8gICB2YXIgQjA9MTtcclxuICAvLyAgIHZhciBBMT0xO1xyXG4gIC8vICAgdmFyIEIxPTE7XHJcbiAgLy8gICB2YXIgTTk9MDtcclxuICAvLyAgIHZhciBBMj0wO1xyXG4gIC8vICAgdmFyIEM5O1xyXG4gIC8vICAgd2hpbGUgKE1hdGguYWJzKChBMS1BMikvQTEpPi4wMDAwMSkge1xyXG4gIC8vICAgICBBMj1BMTtcclxuICAvLyAgICAgQzk9LShBK005KSooQStCK005KSpYLyhBKzIqTTkpLyhBKzIqTTkrMSk7XHJcbiAgLy8gICAgIEEwPUExK0M5KkEwO1xyXG4gIC8vICAgICBCMD1CMStDOSpCMDtcclxuICAvLyAgICAgTTk9TTkrMTtcclxuICAvLyAgICAgQzk9TTkqKEItTTkpKlgvKEErMipNOS0xKS8oQSsyKk05KTtcclxuICAvLyAgICAgQTE9QTArQzkqQTE7XHJcbiAgLy8gICAgIEIxPUIwK0M5KkIxO1xyXG4gIC8vICAgICBBMD1BMC9CMTtcclxuICAvLyAgICAgQjA9QjAvQjE7XHJcbiAgLy8gICAgIEExPUExL0IxO1xyXG4gIC8vICAgICBCMT0xO1xyXG4gIC8vICAgfVxyXG4gIC8vICAgcmV0dXJuIEExL0FcclxuICAvLyB9LFxyXG5cclxuXHJcblxyXG5cclxuXHJcbn1cclxuXHJcblxyXG5leHBvcnQgZGVmYXVsdCB3ZWxjaHMgXHJcblxyXG5cclxuLy8gZnVuY3Rpb24gZ2V0RmFsc2VEaXNjb3ZlcnlSYXRlKEZQLCBUUCl7XHJcbi8vICAgLypDYWxjdWxhdGUgdGhlIEZhbHNlIERpc2NvdmVyeSBSYXRlIChGRFIpXHJcbi8vICAgRlA6IEZhbHNlIFBvc2l0aXZlXHJcbi8vICAgVFA6IFRydWUgUG9zaXRpdmVcclxuLy8gICAqL1xyXG4vLyAgIHJldHVybiBtYXRoLnJvdW5kKDEwMCpGUC8oRlAgKyBUUCksMik7XHJcbi8vIH1cclxuXHJcblxyXG5cclxuLy8gZnVuY3Rpb24gY29tcHV0ZUFyZWEoeCwgZGYpIHtcclxuLy8gICAgIFg9ZXZhbCh4KVxyXG4vLyAgICAgZGY9ZXZhbChkZilcclxuLy8gICAgIHdpdGggKE1hdGgpIHtcclxuLy8gXHRcdGlmIChkZjw9MCkge1xyXG4vLyBcdFx0XHRhbGVydChcIkRlZ3JlZXMgb2YgZnJlZWRvbSBtdXN0IGJlIHBvc2l0aXZlXCIpXHJcbi8vIFx0XHR9IGVsc2Uge1xyXG4vLyBcdFx0XHRBPWRmLzI7XHJcbi8vIFx0XHRcdFM9QSsuNTtcclxuLy8gXHRcdFx0Wj1kZi8oZGYrWCpYKTtcclxuLy8gXHRcdFx0QlQ9ZXhwKExvZ0dhbW1hKFMpLUxvZ0dhbW1hKC41KS1Mb2dHYW1tYShBKStBKmxvZyhaKSsuNSpsb2coMS1aKSk7XHJcbi8vIFx0XHRcdGlmIChaPChBKzEpLyhTKzIpKSB7XHJcbi8vIFx0XHRcdFx0YmV0YWNkZj1CVCpCZXRpbmMoWixBLC41KVxyXG4vLyBcdFx0XHR9IGVsc2Uge1xyXG4vLyBcdFx0XHRcdGJldGFjZGY9MS1CVCpCZXRpbmMoMS1aLC41LEEpXHJcbi8vIFx0XHRcdH1cclxuLy8gXHRcdFx0aWYgKFg8MCkge1xyXG4vLyBcdFx0XHRcdHRjZGY9YmV0YWNkZi8yXHJcbi8vIFx0XHRcdH0gZWxzZSB7XHJcbi8vIFx0XHRcdFx0dGNkZj0xLWJldGFjZGYvMlxyXG4vLyBcdFx0XHR9XHJcbi8vIFx0XHR9XHJcbi8vIFx0XHQvLyB0Y2RmPXJvdW5kKHRjZGYqMTAwMDAwKS8xMDAwMDA7XHJcbi8vIFx0XHQvLyB0Y2RmPXRjZGYqMTAwMDAwLzEwMDAwMDtcclxuLy8gXHR9XHJcbi8vICAgICByZXR1cm4gcm91bmQodGNkZik7XHJcbi8vIH1cclxuXHJcblxyXG5cclxuLy8gZnVuY3Rpb24gTG9nR2FtbWEoWikge1xyXG4vLyBcdHdpdGggKE1hdGgpIHtcclxuLy8gXHRcdHZhciBTPTErNzYuMTgwMDkxNzMvWi04Ni41MDUzMjAzMy8oWisxKSsyNC4wMTQwOTgyMi8oWisyKS0xLjIzMTczOTUxNi8oWiszKSsuMDAxMjA4NTgwMDMvKForNCktLjAwMDAwNTM2MzgyLyhaKzUpO1xyXG4vLyBcdFx0dmFyIExHPSAoWi0uNSkqbG9nKForNC41KS0oWis0LjUpK2xvZyhTKjIuNTA2NjI4Mjc0NjUpO1xyXG4vLyBcdH1cclxuLy8gXHRyZXR1cm4gTEdcclxuLy8gfVxyXG5cclxuLy8gZnVuY3Rpb24gQmV0aW5jKFgsQSxCKSB7XHJcbi8vIFx0dmFyIEEwPTA7XHJcbi8vIFx0dmFyIEIwPTE7XHJcbi8vIFx0dmFyIEExPTE7XHJcbi8vIFx0dmFyIEIxPTE7XHJcbi8vIFx0dmFyIE05PTA7XHJcbi8vIFx0dmFyIEEyPTA7XHJcbi8vIFx0dmFyIEM5O1xyXG4vLyBcdHdoaWxlIChNYXRoLmFicygoQTEtQTIpL0ExKT4uMDAwMDEpIHtcclxuLy8gXHRcdEEyPUExO1xyXG4vLyBcdFx0Qzk9LShBK005KSooQStCK005KSpYLyhBKzIqTTkpLyhBKzIqTTkrMSk7XHJcbi8vIFx0XHRBMD1BMStDOSpBMDtcclxuLy8gXHRcdEIwPUIxK0M5KkIwO1xyXG4vLyBcdFx0TTk9TTkrMTtcclxuLy8gXHRcdEM5PU05KihCLU05KSpYLyhBKzIqTTktMSkvKEErMipNOSk7XHJcbi8vIFx0XHRBMT1BMCtDOSpBMTtcclxuLy8gXHRcdEIxPUIwK0M5KkIxO1xyXG4vLyBcdFx0QTA9QTAvQjE7XHJcbi8vIFx0XHRCMD1CMC9CMTtcclxuLy8gXHRcdEExPUExL0IxO1xyXG4vLyBcdFx0QjE9MTtcclxuLy8gXHR9XHJcbi8vIFx0cmV0dXJuIEExL0FcclxuLy8gfVxyXG5cclxuXHJcblxyXG5cclxuXHJcbi8vIGZ1bmN0aW9uIGdldExpbmVDaGFydChheGVzLCBncm91cDEsIGdyb3VwMiwgcF92YWx1ZSwgY3JpdF90X3ZhbHVlKXtcclxuLy8gICByZXR1cm4gbmV3IENoYXJ0KGVsZW0oXCJsaW5lX2NoYXJ0XCIpLCB7XHJcbi8vICAgICAgIHR5cGU6ICdzY2F0dGVyJyxcclxuLy8gICAgICAgZGF0YToge1xyXG4vLyAgICAgICAgIGRhdGFzZXRzOiBbe1xyXG4vLyAgICAgICAgICAgICBkYXRhOiBbXHJcbi8vICAgICAgICAgICAgICAge3g6IGF4ZXMueF9taW4sIHk6IDB9LFxyXG4vLyAgICAgICAgICAgICAgIHt4OiBheGVzLnhfbWF4LCB5OiAwfSxcclxuLy8gICAgICAgICAgICAgXSxcclxuLy8gICAgICAgICAgICAgbGFiZWw6IFwicmVmc1wiLFxyXG4vLyAgICAgICAgICAgICBib3JkZXJDb2xvcjogXCJ0cmFuc3BhcmVudFwiLFxyXG4vLyAgICAgICAgICAgICBmaWxsOiBmYWxzZVxyXG4vLyAgICAgICAgICAgfSx7XHJcbi8vICAgICAgICAgICAgIGRhdGE6IGdyb3VwMS5kaXN0LFxyXG4vLyAgICAgICAgICAgICBsYWJlbDogXCJHcm91cCAxXCIsXHJcbi8vICAgICAgICAgICAgIGJvcmRlckNvbG9yOiBcIiNmZjAwMDBcIixcclxuLy8gICAgICAgICAgICAgZmlsbDogZmFsc2VcclxuLy8gICAgICAgICAgIH0sIHtcclxuLy8gICAgICAgICAgICAgZGF0YTogZ3JvdXAyLmRpc3QsXHJcbi8vICAgICAgICAgICAgIGxhYmVsOiBcIkdyb3VwIDJcIixcclxuLy8gICAgICAgICAgICAgYm9yZGVyQ29sb3I6IFwiIzAwMDBmZlwiLFxyXG4vLyAgICAgICAgICAgICBmaWxsOiBmYWxzZSxcclxuLy8gICAgICAgICAgIH0sIHtcclxuLy8gICAgICAgICAgICAgZGF0YTogW10sIC8vIEFscGhhIEN1cnZlXHJcbi8vICAgICAgICAgICAgIGxhYmVsOiBcIlxcdTAzQjFcIixcclxuLy8gICAgICAgICAgICAgYm9yZGVyQ29sb3I6IFwidHJhbnNwYXJlbnRcIixcclxuLy8gICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIiNmZjAwMDA1NVwiLFxyXG4vLyAgICAgICAgICAgICBmaWxsOiB0cnVlXHJcbi8vICAgICAgICAgICB9LCB7XHJcbi8vICAgICAgICAgICAgIGRhdGE6IFtdLCAvLyBCZXRhIEN1cnZlXHJcbi8vICAgICAgICAgICAgIGxhYmVsOiBcIlxcdTAzQjJcIixcclxuLy8gICAgICAgICAgICAgYm9yZGVyQ29sb3I6IFwidHJhbnNwYXJlbnRcIixcclxuLy8gICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIiMwMDAwZmY1NVwiLFxyXG4vLyAgICAgICAgICAgICBmaWxsOiB0cnVlXHJcbi8vICAgICAgICAgICB9XHJcbi8vICAgICAgICAgXVxyXG4vLyAgICAgICB9LFxyXG4vLyAgICAgICBvcHRpb25zOiB7XHJcbi8vICAgICAgICAgYW5pbWF0aW9uOiBmYWxzZSxcclxuLy8gICAgICAgICB0aXRsZToge1xyXG4vLyAgICAgICAgICAgZGlzcGxheTogZmFsc2UsXHJcbi8vICAgICAgICAgICB0ZXh0OiAndC10ZXN0J1xyXG4vLyAgICAgICAgIH0sXHJcbi8vICAgICAgICAgbGVnZW5kOntcclxuLy8gICAgICAgICAgIHBvc2l0aW9uOiAnYm90dG9tJyxcclxuLy8gICAgICAgICAgIGxhYmVsczoge1xyXG4vLyAgICAgICAgICAgICBmaWx0ZXI6IGZ1bmN0aW9uKGl0ZW0sIGNoYXJ0KSB7XHJcbi8vICAgICAgICAgICAgICAgICByZXR1cm4gIWl0ZW0udGV4dC5pbmNsdWRlcygncmVmcycpOyAvLyBSZW1vdmUgdGhlIHJlZnMgbGVnZW5kIGl0ZW1cclxuLy8gICAgICAgICAgICAgICB9LFxyXG4vLyAgICAgICAgICAgICAgdXNlUG9pbnRTdHlsZTogdHJ1ZSxcclxuLy8gICAgICAgICAgICB9LFxyXG4vLyAgICAgICAgIH0sXHJcbi8vICAgICAgICAgZWxlbWVudHM6IHtcclxuLy8gICAgICAgICAgIHBvaW50OntcclxuLy8gICAgICAgICAgICAgICByYWRpdXM6IDBcclxuLy8gICAgICAgICAgIH1cclxuLy8gICAgICAgICB9LFxyXG4vLyAgICAgICAgIHNjYWxlczoge1xyXG4vLyAgICAgICAgICAgeEF4ZXM6IFt7XHJcbi8vICAgICAgICAgICAgICAgdGlja3MgOiB7XHJcbi8vICAgICAgICAgICAgICAgbWluOiBheGVzLnhfbWluLFxyXG4vLyAgICAgICAgICAgICAgIHN0ZXBTaXplOiBheGVzLnN0ZXBfc2l6ZSxcclxuLy8gICAgICAgICAgICAgICAgICAgbWF4OiBheGVzLnhfbWF4LFxyXG4vLyAgICAgICAgICAgICAgIH0sXHJcbi8vICAgICAgICAgICAgIGRpc3BsYXk6IHRydWUsXHJcbi8vICAgICAgICAgICAgIGdyaWRMaW5lczoge1xyXG4vLyAgICAgICAgICAgICAgIGRpc3BsYXk6ZmFsc2UsXHJcbi8vICAgICAgICAgICAgIH0sXHJcbi8vICAgICAgICAgICAgIHNjYWxlTGFiZWw6IHtcclxuLy8gICAgICAgICAgICAgICBkaXNwbGF5OiB0cnVlLFxyXG4vLyAgICAgICAgICAgICAgIGxhYmVsU3RyaW5nOiAndCdcclxuLy8gICAgICAgICAgICAgfVxyXG4vLyAgICAgICAgICAgfV0sXHJcbi8vICAgICAgICAgICB5QXhlczogW3tcclxuLy8gICAgICAgICAgICAgdGlja3MgOiB7XHJcbi8vICAgICAgICAgICAgICAgbWluOiAwLFxyXG4vLyAgICAgICAgICAgICAgIG1heDogYXhlcy55X21heCxcclxuLy8gICAgICAgICAgICAgfSxcclxuLy8gICAgICAgICAgICAgZGlzcGxheTogdHJ1ZSxcclxuLy8gICAgICAgICAgICAgc2NhbGVMYWJlbDoge1xyXG4vLyAgICAgICAgICAgICAgIGRpc3BsYXk6IHRydWUsXHJcbi8vICAgICAgICAgICAgICAgbGFiZWxTdHJpbmc6ICdOb3JtYWxpemVkIEZyZXF1ZW5jeSdcclxuLy8gICAgICAgICAgICAgfSxcclxuLy8gICAgICAgICAgICAgZ3JpZExpbmVzOiB7XHJcbi8vICAgICAgICAgICAgICAgICBkaXNwbGF5OmZhbHNlXHJcbi8vICAgICAgICAgICAgIH1cclxuLy8gICAgICAgICAgIH1dXHJcbi8vICAgICAgICAgfSxcclxuLy8gICAgICAgICBhbm5vdGF0aW9uOiB7XHJcbi8vICAgICAgICAgICBhbm5vdGF0aW9uczogW3tcclxuLy8gICAgICAgICAgICAgdHlwZTogJ2xpbmUnLFxyXG4vLyAgICAgICAgICAgICBtb2RlOiAndmVydGljYWwnLFxyXG4vLyAgICAgICAgICAgICBzY2FsZUlEOiAneC1heGlzLTEnLFxyXG4vLyAgICAgICAgICAgICB2YWx1ZTogdF92YWx1ZSxcclxuLy8gICAgICAgICAgICAgYm9yZGVyQ29sb3I6ICcjYzhjOGM4JyxcclxuLy8gICAgICAgICAgICAgYm9yZGVyV2lkdGg6IDIsXHJcbi8vICAgICAgICAgICAgIGJvcmRlckRhc2g6IFsxMCw1XSxcclxuLy8gICAgICAgICAgICAgbGFiZWw6IHtcclxuLy8gICAgICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxyXG4vLyAgICAgICAgICAgICAgIGNvbnRlbnQ6ICdwID0gJyArIHBfdmFsdWUsXHJcbi8vICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAndHJhbnNwYXJlbnQnLFxyXG4vLyAgICAgICAgICAgICAgIGZvbnRDb2xvcjogJyNjOGM4YzgnLFxyXG4vLyAgICAgICAgICAgICAgIHBvc2l0aW9uOiBcInRvcFwiLFxyXG4vLyAgICAgICAgICAgICB9XHJcbi8vICAgICAgICAgICB9LHtcclxuLy8gICAgICAgICAgICAgdHlwZTogJ2xpbmUnLFxyXG4vLyAgICAgICAgICAgICBtb2RlOiAndmVydGljYWwnLFxyXG4vLyAgICAgICAgICAgICBzY2FsZUlEOiAneC1heGlzLTEnLFxyXG4vLyAgICAgICAgICAgICB2YWx1ZTogY3JpdF90X3ZhbHVlLFxyXG4vLyAgICAgICAgICAgICBib3JkZXJDb2xvcjogJyNmZjcwMzQnLFxyXG4vLyAgICAgICAgICAgICBib3JkZXJXaWR0aDogMixcclxuLy8gICAgICAgICAgICAgbGFiZWw6IHtcclxuLy8gICAgICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxyXG4vLyAgICAgICAgICAgICAgIGNvbnRlbnQ6ICdcXHUwM0IxJyxcclxuLy8gICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICd0cmFuc3BhcmVudCcsXHJcbi8vICAgICAgICAgICAgICAgZm9udENvbG9yOiAnIzRkNGU0ZicsXHJcbi8vICAgICAgICAgICAgICAgeUFkanVzdDogMjAsXHJcbi8vICAgICAgICAgICAgICAgcG9zaXRpb246IFwidG9wXCIsXHJcbi8vICAgICAgICAgICAgIH1cclxuLy8gICAgICAgICAgIH1cclxuLy8gICAgICAgICAgIF0sXHJcbi8vICAgICAgICAgICBkcmF3VGltZTogXCJhZnRlckRhdGFzZXRzRHJhd1wiIFxyXG4vLyAgICAgICAgIH1cclxuLy8gICAgICAgfVxyXG4vLyAgICAgfSk7XHJcbi8vIH1cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuLy8gZnVuY3Rpb24gZ2V0Uk9DQ2hhcnQocm9jX2N1cnZlKXtcclxuLy8gICByZXR1cm4gbmV3IENoYXJ0KGVsZW0oXCJyb2NfY3VydmVcIiksIHtcclxuLy8gICAgICAgdHlwZTogJ3NjYXR0ZXInLFxyXG4vLyAgICAgICBkYXRhOiB7XHJcbi8vICAgICAgICAgZGF0YXNldHM6IFt7XHJcbi8vICAgICAgICAgICAgIGRhdGE6IFtcclxuLy8gICAgICAgICAgICAgICB7eDogMCwgeTogMH0sXHJcbi8vICAgICAgICAgICAgICAge3g6IDEsIHk6IDF9LFxyXG4vLyAgICAgICAgICAgICBdLFxyXG4vLyAgICAgICAgICAgICBsYWJlbDogXCJyZWZzXCIsXHJcbi8vICAgICAgICAgICAgIGJvcmRlckNvbG9yOiBcInRyYW5zcGFyZW50XCIsXHJcbi8vICAgICAgICAgICAgIGZpbGw6IGZhbHNlXHJcbi8vICAgICAgICAgICB9LHtcclxuLy8gICAgICAgICAgICAgZGF0YTogW10sIFxyXG4vLyAgICAgICAgICAgICBsYWJlbDogXCJUUFJcIixcclxuLy8gICAgICAgICAgICAgYm9yZGVyQ29sb3I6IFwiIzAwMDAwMFwiLFxyXG4vLyAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiIzAwMDAwMFwiLFxyXG4vLyAgICAgICAgICAgICBmaWxsOiB0cnVlLFxyXG4vLyAgICAgICAgICAgICBwb2ludFJhZGl1czogNFxyXG4vLyAgICAgICAgICAgfSwge1xyXG4vLyAgICAgICAgICAgICBkYXRhOiBbe3g6MCx5OjB9LCB7eDoxLHk6MX1dLCAvLyByYW5kb20gY3VydmUgZm9yIHJlZmVyZW5jZVxyXG4vLyAgICAgICAgICAgICBsYWJlbDogXCJSYW5kb21cIixcclxuLy8gICAgICAgICAgICAgYm9yZGVyQ29sb3I6IFwiI2RlZGVkZVwiLFxyXG4vLyAgICAgICAgICAgICBmaWxsOiBmYWxzZVxyXG4vLyAgICAgICAgICAgfSx7XHJcbi8vICAgICAgICAgICAgIGRhdGE6IHJvY19jdXJ2ZSxcclxuLy8gICAgICAgICAgICAgbGFiZWw6IFwiUk9DIGN1cnZlXCIsXHJcbi8vICAgICAgICAgICAgIGJvcmRlckNvbG9yOiBcIiM3NjAwYmNcIixcclxuLy8gICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIiNjYTVjZGRcIixcclxuLy8gICAgICAgICAgICAgZmlsbDogdHJ1ZVxyXG4vLyAgICAgICAgICAgICAvLyAscG9pbnRSYWRpdXM6IDRcclxuLy8gICAgICAgICAgIH1cclxuLy8gICAgICAgICBdXHJcbi8vICAgICAgIH0sXHJcbi8vICAgICAgIG9wdGlvbnM6IHtcclxuLy8gICAgICAgICBhbmltYXRpb246IGZhbHNlLFxyXG4vLyAgICAgICAgIHRpdGxlOiB7XHJcbi8vICAgICAgICAgICBkaXNwbGF5OiBmYWxzZSxcclxuLy8gICAgICAgICAgIHRleHQ6ICd0LXRlc3QnXHJcbi8vICAgICAgICAgfSxcclxuLy8gICAgICAgICBsZWdlbmQ6e1xyXG4vLyAgICAgICAgICAgcG9zaXRpb246ICdib3R0b20nLFxyXG4vLyAgICAgICAgICAgbGFiZWxzOiB7XHJcbi8vICAgICAgICAgICAgIGZpbHRlcjogZnVuY3Rpb24oaXRlbSwgY2hhcnQpIHtcclxuLy8gICAgICAgICAgICAgICAgIHJldHVybiAhaXRlbS50ZXh0LmluY2x1ZGVzKCdyZWZzJyk7IC8vIFJlbW92ZSB0aGUgcmVmcyBsZWdlbmQgaXRlbVxyXG4vLyAgICAgICAgICAgICAgIH0sXHJcbi8vICAgICAgICAgICAgICB1c2VQb2ludFN0eWxlOiB0cnVlLFxyXG4vLyAgICAgICAgICAgIH0sXHJcbi8vICAgICAgICAgfSxcclxuLy8gICAgICAgICBlbGVtZW50czoge1xyXG4vLyAgICAgICAgICAgcG9pbnQ6e1xyXG4vLyAgICAgICAgICAgICAgIHJhZGl1czogMFxyXG4vLyAgICAgICAgICAgfVxyXG4vLyAgICAgICAgIH0sXHJcbi8vICAgICAgICAgc2NhbGVzOiB7XHJcbi8vICAgICAgICAgICB4QXhlczogW3tcclxuLy8gICAgICAgICAgICAgICB0aWNrcyA6IHtcclxuLy8gICAgICAgICAgICAgICAgIG1pbjogMCxcclxuLy8gICAgICAgICAgICAgICAgIHN0ZXBTaXplOiAwLjIsXHJcbi8vICAgICAgICAgICAgICAgICAvLyBzdGVwVmFsdWU6IDAuMixcclxuLy8gICAgICAgICAgICAgICAgIHN0ZXBzOiAxMCxcclxuLy8gICAgICAgICAgICAgICAgIG1heDogMSxcclxuLy8gICAgICAgICAgICAgICB9LFxyXG4vLyAgICAgICAgICAgICBkaXNwbGF5OiB0cnVlLFxyXG4vLyAgICAgICAgICAgICBncmlkTGluZXM6IHtcclxuLy8gICAgICAgICAgICAgICBkaXNwbGF5OmZhbHNlLFxyXG4vLyAgICAgICAgICAgICB9LFxyXG4vLyAgICAgICAgICAgICBzY2FsZUxhYmVsOiB7XHJcbi8vICAgICAgICAgICAgICAgZGlzcGxheTogdHJ1ZSxcclxuLy8gICAgICAgICAgICAgICBsYWJlbFN0cmluZzogJ0ZhbHNlIHBvc2l0aXZlIHJhdGUgKFxcdTAzQjEpJ1xyXG4vLyAgICAgICAgICAgICB9XHJcbi8vICAgICAgICAgICB9XSxcclxuLy8gICAgICAgICAgIHlBeGVzOiBbe1xyXG4vLyAgICAgICAgICAgICB0aWNrcyA6IHtcclxuLy8gICAgICAgICAgICAgICBtaW46IDAsXHJcbi8vICAgICAgICAgICAgICAgc3RlcFNpemU6IDAuMixcclxuLy8gICAgICAgICAgICAgICBtYXg6IDEsXHJcbi8vICAgICAgICAgICAgIH0sXHJcbi8vICAgICAgICAgICAgIGRpc3BsYXk6IHRydWUsXHJcbi8vICAgICAgICAgICAgIHNjYWxlTGFiZWw6IHtcclxuLy8gICAgICAgICAgICAgICBkaXNwbGF5OiB0cnVlLFxyXG4vLyAgICAgICAgICAgICAgIGxhYmVsU3RyaW5nOiAnVHJ1ZSBwb3NpdGl2ZSByYXRlICgxIC0gXFx1MDNCMiknXHJcbi8vICAgICAgICAgICAgIH0sXHJcbi8vICAgICAgICAgICAgIGdyaWRMaW5lczoge1xyXG4vLyAgICAgICAgICAgICAgICAgZGlzcGxheTpmYWxzZVxyXG4vLyAgICAgICAgICAgICB9XHJcbi8vICAgICAgICAgICB9XVxyXG4vLyAgICAgICAgIH0sXHJcbi8vICAgICAgICAgYW5ub3RhdGlvbjoge1xyXG4vLyAgICAgICAgICAgYW5ub3RhdGlvbnM6IFt7XHJcbi8vICAgICAgICAgICAgIHR5cGU6ICdsaW5lJyxcclxuLy8gICAgICAgICAgICAgbW9kZTogJ3ZlcnRpY2FsJyxcclxuLy8gICAgICAgICAgICAgc2NhbGVJRDogJ3gtYXhpcy0xJyxcclxuLy8gICAgICAgICAgICAgdmFsdWU6IHRfdmFsdWUsXHJcbi8vICAgICAgICAgICAgIGJvcmRlckNvbG9yOiAnI2M4YzhjOCcsXHJcbi8vICAgICAgICAgICAgIGJvcmRlcldpZHRoOiAyLFxyXG4vLyAgICAgICAgICAgICBib3JkZXJEYXNoOiBbMTAsNV0sXHJcbi8vICAgICAgICAgICAgIGxhYmVsOiB7XHJcbi8vICAgICAgICAgICAgICAgZW5hYmxlZDogdHJ1ZSxcclxuLy8gICAgICAgICAgICAgICBjb250ZW50OiAncCA9ICcsXHJcbi8vICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAndHJhbnNwYXJlbnQnLFxyXG4vLyAgICAgICAgICAgICAgIGZvbnRDb2xvcjogJyNjOGM4YzgnLFxyXG4vLyAgICAgICAgICAgICAgIHBvc2l0aW9uOiBcInRvcFwiLFxyXG4vLyAgICAgICAgICAgICB9XHJcbi8vICAgICAgICAgICB9LHtcclxuLy8gICAgICAgICAgICAgdHlwZTogJ2xpbmUnLFxyXG4vLyAgICAgICAgICAgICBtb2RlOiAndmVydGljYWwnLFxyXG4vLyAgICAgICAgICAgICBzY2FsZUlEOiAneC1heGlzLTEnLFxyXG4vLyAgICAgICAgICAgICB2YWx1ZTogcF92YWx1ZSxcclxuLy8gICAgICAgICAgICAgYm9yZGVyQ29sb3I6ICcjZmY3MDM0JyxcclxuLy8gICAgICAgICAgICAgYm9yZGVyV2lkdGg6IDIsXHJcbi8vICAgICAgICAgICAgIGxhYmVsOiB7XHJcbi8vICAgICAgICAgICAgICAgZW5hYmxlZDogdHJ1ZSxcclxuLy8gICAgICAgICAgICAgICBjb250ZW50OiAnJyxcclxuLy8gICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICd0cmFuc3BhcmVudCcsXHJcbi8vICAgICAgICAgICAgICAgZm9udENvbG9yOiAnIzRkNGU0ZicsXHJcbi8vICAgICAgICAgICAgICAgeUFkanVzdDogMjAsXHJcbi8vICAgICAgICAgICAgICAgcG9zaXRpb246IFwidG9wXCIsXHJcbi8vICAgICAgICAgICAgIH1cclxuLy8gICAgICAgICAgIH1cclxuLy8gICAgICAgICAgIF0sXHJcbi8vICAgICAgICAgICBkcmF3VGltZTogXCJhZnRlckRhdGFzZXRzRHJhd1wiIFxyXG4vLyAgICAgICAgIH1cclxuLy8gICAgICAgfVxyXG4vLyAgICAgfSk7XHJcbi8vIH1cclxuXHJcblxyXG4vLyAgICAgLypcclxuLy8gICAgIEZ1bmN0aW9ucyBiZWxvdyBtYXkgYmUgdXNlZCBhdCBhIGZ1dHVyZSBkYXRlLlxyXG5cclxuXHJcbi8vICAgICBCRUxPVyBGT1IgTk9STUFMIENVUlZFIChaLVRFU1QpXHJcbi8vICAgICBmdW5jdGlvbiBlcnJvcl9mKHgsIG1lYW4sIHNkKXtcclxuLy8gICAgICAgcmV0dXJuICgxLyhzZCptYXRoLnNxcnQoMiptYXRoLnBpKSkpKm1hdGguZXhwKCgtKCh4LW1lYW4pICoqIDIpKS8oMipzZCAqKiAyKSk7XHJcbi8vICAgICB9XHJcblxyXG4vLyAgICAgZnVuY3Rpb24gYXJlYV91bmRlcl9jdXJ2ZSh4MSwgeDIsIG1lYW4sIHNkKXtcclxuLy8gICAgICAgcmV0dXJuIC0wLjUqKG1hdGguZXJmKChtZWFuLXgyKS8obWF0aC5zcXJ0KDIpKnNkKSkgLSBtYXRoLmVyZigobWVhbi14MSkvKG1hdGguc3FydCgyKSpzZCkpKTtcclxuLy8gICAgIH1cclxuXHJcblxyXG4vLyAgICAgY29uc3Qgd2lkdGggID0gd2luZG93LmlubmVyV2lkdGggfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoIHx8IGRvY3VtZW50LmJvZHkuY2xpZW50V2lkdGg7XHJcbi8vICAgICBpZiAod2lkdGggPD0gMTAwMCl7XHJcbi8vICAgICAgIGxpbmVDaGFydC5vcHRpb25zLmFubm90YXRpb24uYW5ub3RhdGlvbnNbMF0ubGFiZWxbJ2VuYWJsZWQnXSA9IHRydWU7XHJcbi8vICAgICAgIGxpbmVDaGFydC5vcHRpb25zLmFubm90YXRpb24uYW5ub3RhdGlvbnNbMV0ubGFiZWxbJ2VuYWJsZWQnXSA9IHRydWU7XHJcbi8vICAgICAgIGxpbmVDaGFydC51cGRhdGUoKTtcclxuLy8gICAgIH1cclxuLy8gICAgICovXHJcblx0XHJcblx0XHJcbi8vICAgICAvKlxyXG4vLyAgICAgQmF5ZXMgRmFjdG9yID0gTGlrZWxpaG9vZCBSYXRpbyA9IFNlbnNpdGl2aXR5IC8gRmFsc2UgUG9zaXRpdmUgUmF0ZVxyXG4vLyAgICAgKi9cclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/welchs.js\n");

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ /* webpack/runtime/getFullHash */
/******/ !function() {
/******/ 	__webpack_require__.h = function() { return "89ea170d36847ffc"; }
/******/ }();
/******/ 
/******/ }
);